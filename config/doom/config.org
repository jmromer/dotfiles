#+title: Emacs Config
#+author: Jacob Römer (jmromer)
#+property: header-args :elisp :tangle yes :comments link
#+startup: org-startup-folded: fold

* contents :TOC_1:
- [[#general][+general]]
- [[#utilities][+utilities]]
- [[#aider][aider]]
- [[#completion][completion]]
- [[#diff-hl][diff-hl]]
- [[#dired][dired]]
- [[#evil][evil]]
- [[#exercism][exercism]]
- [[#flycheck][flycheck]]
- [[#folding][folding]]
- [[#formatting][formatting]]
- [[#gtags][gtags]]
- [[#latex][latex]]
- [[#lookup][lookup]]
- [[#lsp][lsp]]
- [[#magit][magit]]
- [[#magit-time-tracking][magit: time tracking]]
- [[#magit-tagged-commits][magit: tagged commits]]
- [[#markdown][markdown]]
- [[#org][org]]
- [[#projectile][projectile]]
- [[#python][python]]
- [[#react--web][react & web]]
- [[#ruby][ruby]]
- [[#rust][rust]]
- [[#smartparens][smartparens]]
- [[#treesitter][treesitter]]
- [[#typopunct][typopunct]]
- [[#webkit][webkit]]
- [[#word-chars][word chars]]
- [[#workspaces][workspaces]]
- [[#yankee][yankee]]
- [[#yasnippet][yasnippet]]
- [[#hacks][hacks]]

* +general

See [[https://github.com/hlissner/doom-emacs/blob/develop/modules/lang/emacs-lisp/demos.org][API Demos]] for examples.

** confirm-kill-emacs

#+begin_src elisp
(setq confirm-kill-emacs nil)
#+end_src

** select-enable-clipboard

#+begin_src elisp
(setq select-enable-clipboard t)
#+end_src

** which-key

#+begin_src elisp
(setq which-key-idle-delay 1
      which-key-idle-secondary-delay 0.5)
#+end_src
** literate config

Don't tangle on save.

#+begin_src elisp
(remove-hook 'org-mode-hook #'+literate-enable-recompile-h)
#+end_src

Provide a command to trigger tangling manually.

#+begin_src elisp
(defun +config:tangle ()
  "Tangle config.org to Emacs lisp."
  (interactive)
  (+literate-tangle-h))
#+end_src

** display

Set fonts. NB: =doom-variable-pitch-font= could use updating.
#+begin_src elisp
(setq doom-font (font-spec :family "Monaco" :size 16)
      doom-variable-pitch-font (font-spec :family "Monaco" :size 16)
      doom-big-font (font-spec :family "Monaco" :size 24)
      doom-theme 'doom-one
      display-line-numbers-type 'relative
      fancy-splash-image nil
      +doom-dashboard-ascii-banner-fn nil)
#+end_src

Use the project name for the frame title, if available, otherwise the buffer name.
#+begin_src elisp
(setq frame-title-format
      '((:eval
         (if (projectile-project-p)
             (format "%s" (projectile-project-name))
           (buffer-name)))))
#+end_src

Start Emacs maximized.
#+begin_src elisp
(add-to-list 'initial-frame-alist '(fullscreen . maximized))
#+end_src

Toggle light/dark theme based on the current OS setting.

#+begin_src elisp
(defun +set-preferred-theme (appearance)
  "Load theme, taking current system APPEARANCE into consideration."
  (mapc #'disable-theme custom-enabled-themes)
  (pcase appearance
    ('light (load-theme 'doom-oksolar-light t))
    ('dark (load-theme 'doom-one t))))

(add-hook 'ns-system-appearance-change-functions #'+set-preferred-theme)
#+end_src

Tell =ispell= to shut up.

#+begin_src elisp
(advice-add 'ispell-lookup-words :around
            (lambda (orig &rest args)
              (shut-up (apply orig args))))
#+end_src

** display: doom dashboard

#+begin_src elisp
(set-face-foreground 'doom-dashboard-footer-icon "#5B6268")
(set-face-foreground 'doom-dashboard-footer "#5B6268")
#+end_src

Override the widget footer function to replace the icon.
#+begin_src elisp
(defun doom-dashboard-widget-footer ()
  (insert
   "\n"
   (+doom-dashboard--center
    (- +doom-dashboard--width 2)
    (with-temp-buffer
      (insert-text-button (nerd-icons-sucicon "nf-custom-emacs" 'doom-dashboard-footer-icon :height 4)
                          'action (lambda (_) (browse-url "https://github.com/hlissner/doom-emacs"))
                          'follow-link t
                          'help-echo "Doom Emacs")
      (buffer-string)))
   "\n"))
#+end_src

Override the benchmark reporting to customize.
#+begin_src elisp
(defun doom-display-benchmark-h (&optional return-p)
  "Display a benchmark including number of packages and modules loaded.

If RETURN-P, return the message as a string instead of displaying it."
  (funcall (if return-p #'format #'message)
           "Emacs loaded %d packages across %d modules in %.03fs"
           (- (length load-path) (length (get 'load-path 'initial-value)))
           (if doom-modules (hash-table-count doom-modules) -1)
           doom-init-time))
#+end_src

Add items to the dashboard menu.
#+begin_src elisp
(add-to-list '+doom-dashboard-menu-sections
             '("Open terminal emulator"
               :icon (nerd-icons-octicon "nf-oct-terminal" :face 'doom-dashboard-menu-title)
               :action +vterm/here))
(add-to-list '+doom-dashboard-menu-sections
             '("Switch to scratch buffer"
               :icon (nerd-icons-octicon "nf-oct-pencil" :face 'doom-dashboard-menu-title)
               :action doom/switch-to-scratch-buffer))
(add-to-list '+doom-dashboard-menu-sections
             '("Open empty buffer"
               :icon (nerd-icons-octicon "nf-oct-file" :face 'doom-dashboard-menu-title)
               :action evil-buffer-new))
#+end_src

** display: hl-todo

Enable hl-todo mode in certain text modes.

#+begin_src elisp
(after! hl-todo
  (add-hook! markdown-mode #'hl-todo-mode)
  (add-hook! org-mode #'hl-todo-mode))
#+end_src

** display: line numbers

Disable line-numbering in org and markdown modes

#+begin_src elisp
(defun +config:display:disable-line-numbers ()
  "Disable line numbers in the current buffer."
  (setq-local display-line-numbers nil))

(add-hook! '(org-mode-hook markdown-mode-hook) #'+config:display:disable-line-numbers)
#+end_src

** display: layout

#+begin_src elisp
(defun layout-main ()
  (interactive)
  (let ((w-main nil)
        (w-top (selected-window))
        (w-btm nil)
        (b-main (dired-noselect (or (projectile-project-root) "~/.dotfiles")))
        (b-top (find-file-noselect (format "%s/%s" (getenv "ORG_HOME") +org-capture-todo-file)))
        (b-btm (get-buffer-create "*scratch*")))
    (delete-other-windows)
    (set-window-buffer w-top b-top)
    (setq w-main
          (window--display-buffer
           b-main
           (split-window w-top (/ (window-width) 4) 'left)
           'window
           '((display-buffer-mark-dedicated . t))))
    (setq w-btm
          (window--display-buffer
           b-btm
           (split-window w-top (* 2 (/ (window-height) 3)) 'below)
           'window
           '((display-buffer-mark-dedicated . t))))
    (select-window w-main)))
#+end_src

** scrolling

#+begin_src elisp
(defun scroll-other-window-up ()
  "Scroll the other window up."
  (interactive)
  (scroll-other-window -3))

(defun scroll-other-window-down ()
  "Scroll the other window down."
  (interactive)
  (scroll-other-window 3))

(map! "M-p" #'scroll-other-window-up)
(map! "M-n" #'scroll-other-window-down)
#+end_src

** leader keys

Use comma for the local leader key.

#+begin_src elisp
(setq doom-localleader-key ",")
#+end_src

** super keys

Some general purpose super-key keybindings.

#+begin_src elisp
(map! :desc "pwd vterm"     "s-'"   #'vterm-other-window
      :desc "project vterm" "s-\""  #'+vterm/toggle
      :desc "full vterm"    "s-C-'" #'(lambda () (interactive) (+vterm/here t))
         "s-K"   #'kill-current-buffer
         "s-k"   #'bury-buffer
         "s-F"   #'avy-goto-char-timer
         "s-f"   #'avy-goto-char-2
         "s-N"   #'org-projectile-capture-for-current-project
         "s-n"   #'+org-capture/open-frame
  "<s-escape>"   #'evil-escape)
#+end_src

#+begin_src elisp
(map! :ni "s-<return>" #'+make/run)
#+end_src

Meta variants for terminal emacs:

#+begin_src elisp
(setq mac-right-option-modifier 'meta)
(setq mac-option-modifier 'meta)
#+end_src

#+begin_src elisp
   (map! :desc "pwd vterm"     "M-'"   #'vterm-other-window
         :desc "project vterm" "M-\""  #'+vterm/toggle
         :desc "full vterm"    "M-C-'" #'(lambda () (interactive) (+vterm/here t))
         "M-K"   #'kill-current-buffer
         "M-k"   #'bury-buffer
         "M-f"   #'avy-goto-char-2
         "M-F"   #'avy-goto-char-timer
         "M-n"   #'org-capture
         "M-N"   #'org-projectile-project-todo-completing-read
  "<M-escape>"   #'evil-escape)
#+end_src

** identity

Some functionality uses this to identify you, e.g. GPG configuration, email
clients, file templates and snippets.

#+begin_src elisp
(setq user-full-name "Jacob Romer"
      user-mail-address "jmromer@tensorconclave.com")
#+end_src

** credentials

Required [[https://gist.github.com/Azeirah/542f1db12e3ef904abfc7e9c2e83310e][setup]] for using [[https://magit.vc/manual/forge/][forge]].

#+begin_src elisp
(setq authinfo-file (format "%s/config/authinfo.gpg" (getenv "XDG_SECURE_DIR"))
      auth-sources (list 'macos-keychain-generic 'macos-keychain-internet authinfo-file))
#+end_src

** local variables

Allow remembering risky local variables.

#+begin_src elisp
(advice-add 'risky-local-variable-p :override #'ignore)
#+end_src

** indentation

#+begin_src elisp
(setq-default standard-indent 2)
#+end_src

** word counts

#+begin_src elisp
(setq doom-modeline-continuous-word-count-modes
      '(markdown-mode gfm-mode org-mode fundamental-mode))
#+end_src

#+begin_src elisp
(defun +enable-continuous-word-count ()
  (interactive)
  (if (member major-mode doom-modeline-continuous-word-count-modes)
      (setq doom-modeline-enable-word-count (not doom-modeline-enable-word-count))
    (error (format "`%s' not in `doom-modeline-continuous-word-count-modes'" major-mode))))

(map! :leader :prefix "t" :desc "Word count" "W" #'+enable-continuous-word-count)
#+end_src

** tmux-ish keybindings

#+begin_src elisp
(map! "C-h" #'projectile-switch-project
      "C-a m" #'+open-dotfiles
      "C-a -" #'evil-window-split
      "C-a \\" #'evil-window-vsplit)
#+end_src

** recent buffers toggling

#+begin_src elisp
(defun +buffer/other ()
  "Switch to most recent buffer. Repeated calls toggle back and forth between the most recent two buffers."
  (interactive)
  (let ((current (current-buffer))
        (buflist (buffer-list)))
    ;; Remove current buffer from the list
    (setq buflist (delq current buflist))
    ;; Switch to the first buffer in the list (most recently used)
    (switch-to-buffer (car buflist))))

(global-set-key (kbd "s-`") '+buffer/other)
#+end_src

** word wrapping

#+begin_src elisp
(setq +word-wrap-fill-style 'soft)

(dolist (mode '(dired-mode minibuffer-mode completion-list-mode))
  (add-to-list '+word-wrap-disabled-modes mode))

(+global-word-wrap-mode)
#+end_src

* +utilities

Some general-purpose functions.

** +async-shell-command-below

#+begin_src elisp
(defun +async-shell-command-below (command &optional buffer-name proportion)
  "Execute COMMAND, displaying output in buffer (optionally named BUFFER-NAME),
which that takes up PROPORTION of the frame height (default: 0.1).
Dismiss the buffer and window on success, or switch focus to it on failure."
  (let ((buffer-name (or buffer-name "*Async Shell Command*"))
        (proportion (or proportion 0.1))
        (window-min-height 1))
    (with-current-buffer (get-buffer-create buffer-name)
      (setq truncate-lines t))
    (let ((output-window (split-window (selected-window) (floor (* (- 1 proportion) (window-total-height))) 'below)))
      (set-window-buffer output-window buffer-name)
      (set-window-text-height output-window (floor (* proportion (frame-height)))))
    (async-shell-command command buffer-name)
    (set-process-sentinel (get-buffer-process buffer-name)
                          (lambda (process event)
                            (let* ((buffer (process-buffer process))
                                   (window (get-buffer-window buffer)))
                              (if (string= event "finished\n")
                                  (progn
                                    (when (window-live-p window)
                                      (delete-window window))
                                    (kill-buffer buffer))
                                (when (process-live-p process)
                                  (interrupt-process process))
                                (when (window-live-p window)
                                  (progn
                                    (select-window window)
                                    (enlarge-window 15)
                                    (recenter -1)))))))))
#+end_src

** +open-file-in-new-buffer-right

#+begin_src elisp
(defun +open-file-in-new-buffer-right (filename)
  "Open a PDF file in a new buffer to the right of the current buffer, or reload if already open."
  (interactive "fOpen PDF file: ")
  (let ((buffer (get-file-buffer filename))
        (window (get-buffer-window filename)))
    (if buffer
        (if window
            (select-window window)
          (progn
            (split-window-right)
            (other-window 1)
            (switch-to-buffer buffer)
            (revert-buffer :ignore-auto :noconfirm)))
      (progn
        (split-window-right)
        (other-window 1)
        (find-file filename)))))
#+end_src

** file-to-string

#+begin_src elisp
(defun file-to-string (filename)
  "Read the contents of file FILENAME to a string."
  (with-temp-buffer
    (insert-file-contents filename)
    (buffer-string)))
#+end_src

** is-proj-root-p

#+begin_src elisp
(defun is-proj-root-p (filename)
  "Is the given filename FILENAME a project root?"
  (or (file-directory-p (format "%s/.git" filename))
      (file-directory-p (format "%s/.projectile" filename))))
#+end_src

** kill-open-buffers-with-name-prefix

#+begin_src elisp
(defun kill-open-buffers-with-name-prefix (prefix)
  (interactive)
  (seq-do
   #'kill-buffer
   (seq-filter #'(lambda (buffer)
                   (string-prefix-p prefix (buffer-name buffer)))
               (buffer-list))))
#+end_src

** get-url-surrounding-point

#+begin_src elisp
(defun get-url-surrounding-point ()
  (save-excursion
    (let* ((oldpoint (point)) (start (point)) (end (point))
           (syntaxes "w_")
           (not-syntaxes (concat "^" syntaxes)))
      (skip-syntax-backward syntaxes) (setq start (point))
      (goto-char oldpoint)
      (skip-syntax-forward syntaxes) (setq end (point))
      (when (and (eq start oldpoint)
                 (eq end oldpoint))
        ;; Look for preceding word in same line.
        (skip-syntax-backward not-syntaxes (line-beginning-position))
        (if (bolp)
            ;; No preceding word in same line.
            ;; Look for following word in same line.
            (progn
              (skip-syntax-forward not-syntaxes (line-end-position))
              (setq start (point))
              (skip-syntax-forward syntaxes)
              (setq end (point)))
          (setq end (point))
          (skip-syntax-backward syntaxes)
          (setq start (point))))
      ;; If we found something nonempty, return it as a string.
      (unless (= start end)
        (buffer-substring-no-properties start end)))))
#+end_src

** ensure-url

#+begin_src elisp
(defun ensure-url (candidate-str)
  "Ensure CANDIDATE-STR can be interpreted as a URL.
Checking for a scheme (interpolating one if missing) and a hostname with a TLD.
Return nil if the hostname is missing a TLD."
  (when candidate-str
    (let* ((candidate-url (ensure-url-scheme candidate-str))
           (hostname (nth 2 (split-string candidate-url "/"))))
      (when (string-match-p "\\." hostname)
        candidate-url))))
#+end_src

** ensure-url-scheme

#+begin_src elisp
(defun ensure-url-scheme (candidate-str)
  "Ensure CANDIDATE-STR is prefixed with a scheme, or return the string prepended with one"
  (when candidate-str
    (if (or (string-prefix-p "https://" candidate-str t)
            (string-prefix-p "http://" candidate-str t))
        candidate-str
      (format "https://%s" (replace-regexp-in-string "^[^[:word:]]+" "" candidate-str)))))
#+end_src

** yank-buffer-path-dwim

Combines behavior from the following commands, unifying their interfaces with a =C-u= fallback.:

- =+default/yank-buffer-path=
- =+default/yank-buffer-path-relative-to-project=

#+begin_src elisp
(defun buffer-path-dwim (&optional abspath-p)
  "Return the path of the current buffer's file. (If `buffer-file-name' isn't set, use `default-directory'.)
Abbreviate the path: If in a project, relative to project root; otherwise to the tilde-abbreviated user root.
Provide an absolute path if the prefix argument ABSPATH-P is provided."
  (if-let ((file-path buffer-file-name))
      (let* ((proj-path (expand-file-name (locate-dominating-file file-path #'is-proj-root-p)))
             (disp-path (if abspath-p file-path
                          (replace-regexp-in-string (concat "^" proj-path) "" file-path))))
        disp-path)
    (abbreviate-file-name default-directory)))
#+end_src

#+begin_src elisp
(defun yank-buffer-path-dwim (abspath-p)
  "Yank the path of the current buffer's file. (If `buffer-file-name' isn't set, use `default-directory'.)
Abbreviate the path: If in a project, relative to project root; otherwise to the tilde-abbreviated user root.
Provide an absolute path if the prefix argument ABSPATH-P is provided."
  (interactive "P")
  (yank-with-echo (buffer-path-dwim abspath-p)))
#+end_src

#+begin_src elisp
(defun yank-buffer-path-with-line-dwim (abspath-p)
  "Yank the path of the current buffer's file, along with line number of the point's current position.
(If `buffer-file-name' isn't set, use `default-directory'.)
Abbreviate the path: If in a project, relative to project root; otherwise to the tilde-abbreviated user root.
Provide an absolute path if the prefix argument ABSPATH-P is provided."
  (interactive "P")
  (let* ((yanked-path (buffer-path-dwim abspath-p))
         (path-with-num (format "%s:%s" yanked-path (line-number-at-pos))))
    (yank-with-echo path-with-num)))
#+end_src

#+begin_src elisp
(map! :leader :prefix "f" "y" nil)
(map! :leader
      :prefix "f"
      (:prefix ("y" . "yank")
       :desc "path"             "y" #'yank-buffer-path-dwim
       :desc "path (~relative)" "Y" #'+default/yank-buffer-path
       :desc "path+line"        "l" #'yank-buffer-path-with-line-dwim))
#+end_src

** yank-with-echo

#+begin_src elisp
(defun yank-with-echo (yanked &optional echo)
  (progn
    (kill-new yanked)
    (if echo (message echo)
      (message (format "Copied to clipboard: %s" yanked)))))
#+end_src

** +logos-deploy

#+begin_src elisp
(defun +logos-deploy ()
  "Deploy the logos project with a timestamped commit message.
Prompts for an optional commit message suffix."
  (interactive)
  (let* ((default-directory (expand-file-name "~/Writing/logos/"))
         (timestamp (format-time-string "%Y-%m-%d %H:%M"))
         (suffix (read-string "Optional commit message: "))
         (full-message (if (string-empty-p suffix)
                           (format "Update %s" timestamp)
                         (format "Update %s (%s)" timestamp suffix)))
         (command (mapconcat
                   #'identity
                   (list "git add ."
                         (format "git commit -m \"%s\"" full-message)
                         "bin/deploy")
                   " && ")))
    (message "Deploying with commit message: %s" full-message)
    (compile command)))
#+end_src

* aider
#+begin_src elisp
(use-package aider
  :config
  (setq aider-args
        '(
          "--model"  "gpt-4o"
          "--weak-model" "o3-mini"
          "--no-auto-commits"
          "--no-attribute-author"
          "--no-attribute-committer"
          "--no-attribute-commit-message-author"
          "--no-attribute-commit-message-committer"
          )))
#+end_src
* completion

** copilot

Accept completion from GitHub Copilot and fallback to company

#+begin_src elisp
(use-package! copilot
  :hook (prog-mode . copilot-mode)
  :bind (:map copilot-completion-map
              ;; ("<return>" . 'copilot-accept-completion)
              ;; ("RET" . 'copilot-accept-completion)
              ;; ("C-RET" . 'copilot-accept-completion-by-word)
              ;; ("C-<return>" . 'copilot-accept-completion-by-word)
              ("<tab>" . 'copilot-accept-completion)
              ("TAB" . 'copilot-accept-completion)
              ("C-TAB" . 'copilot-accept-completion-by-word)
              ("C-<tab>" . 'copilot-accept-completion-by-word)))

;; If pressing tab to complete sometimes doesn't work you might want to bind
;; completion to another key or try:
;; (after! (evil copilot)
;;   ;; Define the custom function that either accepts the completion or does the default behavior
;;   (defun +copilot-select-or-default ()
;;     (interactive)
;;     ;; Add any other conditions to check for active copilot suggestions, if necessary
;;     (if (and (bound-and-true-p copilot-mode))
;;         (copilot-accept-completion)
;;       (evil-insert 1))) ;; Default action to insert a tab
;;   (map! :i "<tab>" #'+copilot-select-or-default))
#+end_src

Silence warnings when an indentation offset can't be inferred.

#+begin_src elisp
;; ⛔ Warning (copilot): copilot--infer-indentation-offset found no
;;   mode-specific indentation offset.
(setq copilot-indent-offset-warning-disable t)
#+end_src

Strongly recommend to enable childframe option in company module
=((company +childframe))= to prevent overlay conflict.

** company

https://github.com/company-mode/company-mode

Ensure yasnippet is included with all backends

#+begin_src elisp
(defun company-backend-with-yas (backends)
  "Add :with company-yasnippet to company BACKENDS.
Taken from https://github.com/syl20bnr/spacemacs/pull/179."
  (if (and (listp backends)
           (memq 'company-yasnippet backends))
      backends
    (append (if (consp backends)
                backends
              (list backends))
            '(:with company-yasnippet))))

(add-hook! company-mode
  (setq company-backends (mapcar #'company-backend-with-yas company-backends)))
#+end_src

** company keybindings

#+begin_src elisp
(after! company
  (map! :map company-active-map
        :desc "find"           :i "C-f" #'company-search-candidates
        :desc "helpdoc"        :i "C-h" #'company-show-doc-buffer
        :desc "implementation" :i "C-i" #'company-show-location
        :desc "rifle"          :i "C-r" #'company-filter-candidates))
#+end_src

** company-box

Enable [[https://github.com/sebastiencs/company-box][company-box]] to enhance company's visual cues.

#+begin_src elisp
(add-hook! company-mode #'company-box-mode)
#+end_src

Override some distracting default colors.

#+begin_src elisp
(setq company-box-backends-colors '())
#+end_src

* diff-hl

Enable [[https://github.com/dgutov/diff-hl][diff-highlight]] modes globally.

#+begin_src elisp
(after! diff-hl
  (global-diff-hl-mode))
#+end_src

#+begin_src elisp
(map! :n "[h" #'diff-hl-show-hunk-previous
      :n "]h" #'diff-hl-show-hunk-next)
#+End_src

Use a posframe for displaying hunks.

#+begin_src elisp
(after! diff-hl
  (setq diff-hl-show-hunk-function #'diff-hl-show-hunk-posframe))
#+end_src

Add refresh hooks for magit > 2.4.0.

#+begin_src elisp
(after! (:all diff-hl magit)
  (add-hook! magit-pre-refresh #'diff-hl-magit-pre-refresh)
  (add-hook! magit-post-refresh #'diff-hl-magit-post-refresh))
#+end_src

Small improvement to =diff-hl-show-hunk-copy-original-text=.

#+begin_src elisp
(after! diff-hl-show-hunk
  (defun diff-hl-show-hunk-copy-original-text ()
    "Extracts all the lines from BUFFER starting with '-' to the kill ring."
    (interactive)
    (if-let (original-content diff-hl-show-hunk--original-content)
        (yank-with-echo original-content "Original hunk content added to kill-ring"))
    (message "Hunk is a new addition, no content to copy.")))
#+end_src

* dired

From the normal state, Enter dired in the CWD of the current buffer's file with =-=.

#+begin_src elisp
(map! :n "-" #'dired-jump)
#+end_src

#+begin_src elisp
(map! :map dired-mode-map
      :localleader
      :n "," #'casual-dired-tmenu)
#+end_src

* evil

** cursor mode indicators

#+begin_src elisp
(setq evil-normal-state-cursor '(box "light blue")
      evil-insert-state-cursor '(bar "medium sea green")
      evil-visual-state-cursor '(hollow "orange"))
#+end_src

** state messages

Silence state messages.

#+begin_src elisp
(setq evil-emacs-state-message nil
      evil-iedit-insert-state-message nil
      evil-iedit-state-message nil
      evil-insert-state-message nil
      evil-motion-state-message nil
      evil-replace-state-message nil
      evil-visual-state-message nil)
#+end_src

** window navigation

Re-map keybindings to follow when splitting by default.

#+begin_src elisp
(setq evil-vsplit-window-right t
      evil-split-window-below t)

(map! :leader
      :prefix ("w" . "window")
      :desc "split below"  "s"  #'evil-window-split
      :desc "split right"  "v"  #'evil-window-vsplit)
#+end_src

** hybrid evil/emacs keybindings

*** evil-change-back-to-indentation

Better parallels emacs's =C-k= (kill to end of line) and evil's =C= (change to end of line).

#+begin_src elisp
(defun evil-change-line-to-start ()
  "Delete the current line back to indentation level and enter insert state."
  (interactive)
  (kill-line)
  (evil-delete-back-to-indentation)
  (evil-insert-state))

(map! :n  "S"   #'evil-change-line-to-start
      :i  "C-s" #'evil-change-line-to-start)
#+end_src

*** character deletion

Enable some emacs chords in evil insert state:

- =C-k= (kill to end of line)
- =C-d= (delete char)

#+begin_src elisp
(map! :i "C-d" #'evil-delete-char
      :i "C-k" #'evil-delete-line)

(defun +config:keybindings:hybrid ()
  (map! :map (org-mode-map evil-org-mode-map)
        :i "C-d" nil
        :i "C-k" nil))

(add-hook! org-mode :append #'+config:keybindings:hybrid)
#+end_src

** evil-cleverparens

https://github.com/luxbock/evil-cleverparens

NB: Consider [[https://github.com/syohex/lispyville][lispyville]] as an alternative.

#+begin_src elisp
(add-hook! emacs-lisp-mode #'evil-cleverparens-mode)
#+end_src

Disable little-used keybindings likely to conflict with other packages.

#+begin_src elisp
(after! evil-cleverparens
  (map! :map evil-cleverparens-mode-map
        :n "K" nil
        :n "S" nil
        :n "H" nil
        :n "L" nil)
  nil)
#+end_src

** evil-iedit

https://github.com/syl20bnr/evil-iedit-state

#+begin_src elisp
(setq iedit-toggle-key-default nil)
#+end_src

#+begin_src elisp
(after! evil
  (require 'evil-iedit-state)
  (map! :leader
        :prefix ("e". "edit")
        :desc "iedit" :n "i" #'iedit-mode))
#+end_src

** evil-unimpaired

https://github.com/zmaas/evil-unimpaired

#+begin_src elisp
(after! evil-unimpaired
  (evil-unimpaired-mode 1))
#+end_src

** evil-matchit

https://github.com/redguardtoo/evil-matchit

#+begin_src elisp
(after! evil-matchit
  (global-evil-matchit-mode 1))
#+end_src

** evil-quickscope

https://github.com/blorbx/evil-quickscope

#+begin_src elisp
(global-evil-quickscope-mode 1)

(map! :n "C-;" #'evil-repeat-find-char
      :n "C-," #'evil-repeat-find-char-reverse)
#+end_src

** evil-sort

Define "inside" motion for: buffer, paragraphs, delimiters.

#+begin_src elisp
(defun evil-sort-inner (textobj &optional desc)
  "Sort inside the TEXTOBJ surrounding the point.
When DESC is non-nil, sort in descending order.
TEXTOBJ should be a symbol corresponding to `x' in the `evil-inner-x' functions."
  (interactive)
  (let ((evil-textobj (intern (format "evil-inner-%s" textobj)))
        (start-pos (point)))
    (save-excursion
      (let* ((bounds (call-interactively evil-textobj))
             (beg (cl-first bounds))
             (end (cl-second bounds)))
        (sort-lines desc beg end)))
    (goto-char start-pos)))

(defun evil-sort-inner-paragraph (desc)
  "Sort inside the paragraph under the point.
When called with a prefix argument DESC, sort in descending order."
  (interactive "P")
  (evil-sort-inner 'paragraph desc))

(defun evil-sort-inner-buffer (desc)
  "Sort inside the current buffer.
When called with a prefix argument DESC, sort in descending order."
  (interactive "P")
  (evil-sort-inner 'buffer desc))

(defun evil-sort-inner-curly (desc)
  "Sort inside the current curly braces.
When called with a prefix argument DESC, sort in descending order."
  (interactive "P")
  (evil-sort-inner 'curly desc))

(defun evil-sort-inner-paren (desc)
  "Sort inside the current parentheses.
When called with a prefix argument DESC, sort in descending order."
  (interactive "P")
  (evil-sort-inner 'paren desc))

(defun evil-sort-inner-bracket (desc)
  "Sort inside the current parentheses.
When called with a prefix argument DESC, sort in descending order."
  (interactive "P")
  (evil-sort-inner 'bracket desc))
#+end_src

Add sort motions to normal state map.

#+begin_src elisp
(map! :desc "sort paragraph lines" :n "g s i p" #'evil-sort-inner-paragraph
      :desc "sort buffer lines"    :n "g s i g" #'evil-sort-inner-buffer
      :desc "sort inside braces"   :n "g s i {" #'evil-sort-inner-curly
      :desc "sort inside braces"   :n "g s i }" #'evil-sort-inner-curly
      :desc "sort inside brackets" :n "g s i [" #'evil-sort-inner-bracket
      :desc "sort inside brackets" :n "g s i ]" #'evil-sort-inner-bracket
      :desc "sort inside parens"   :n "g s i (" #'evil-sort-inner-paren
      :desc "sort inside parens"   :n "g s i )" #'evil-sort-inner-paren)
#+end_src

** evil-string-inflection

https://github.com/ninrod/evil-string-inflection

Use =g~= operator to cycle through inflection transformations.

#+begin_src elisp
(after! evil
  (require 'evil-string-inflection))
#+end_src

** evil text objects

*** delimiters

#+begin_src elisp
(defmacro define-and-bind-text-object (name key start-regex end-regex)
  (let ((inner-name (make-symbol (concat "evil-inner-" name)))
        (outer-name (make-symbol (concat "evil-a-" name))))
    `(progn
       (evil-define-text-object ,inner-name (count &optional beg end type)
         (evil-select-paren ,start-regex ,end-regex beg end type count nil))
       (evil-define-text-object ,outer-name (count &optional beg end type)
         (evil-select-paren ,start-regex ,end-regex beg end type count t))
       (define-key evil-inner-text-objects-map ,key #',inner-name)
       (define-key evil-outer-text-objects-map ,key #',outer-name))))
#+end_src

#+begin_src elisp
(define-and-bind-text-object "bracket" "[" "\\[" "\\]")
(define-and-bind-text-object "dash" "-" "-" "-")
(define-and-bind-text-object "dollar" "$" "\\$" "\\$")
(define-and-bind-text-object "pipe" "|" "|" "|")
(define-and-bind-text-object "slash" "/" "/" "/")
(define-and-bind-text-object "underscore" "_" "_" "_")
#+end_src

*** evil-inner-buffer

#+begin_src elisp
(evil-define-text-object evil-inner-buffer (count &optional beg end type)
  "Select inner buffer."
  :type line
  (evil-select-inner-object 'buffer beg end type count t))
#+end_src

*** ruby text objects
#+begin_src elisp
(add-hook! ruby-mode #'evil-ruby-text-objects-mode)
#+end_src

* exercism

#+begin_src elisp
(require 'exercism)
#+end_src

#+begin_src elisp
(setq exercism--config-path (format "%s/exercism/user.json" (getenv "XDG_CONFIG_HOME")))
(defun exercism--configure (api-token)
  "Configure excerism with API-TOKEN."
  (setq exercism--api-token api-token)
  (exercism--run-shell-command (concat (shell-quote-argument exercism-executable)
                                       " configure"
                                       " --token " (shell-quote-argument exercism--api-token))
                               (lambda (result) (message "[exercism] configure: %s" result)
                                 (let* ((user-config-path (expand-file-name exercism--config-path))
                                       (user-config-str (exercism--file-to-string user-config-path))
                                       (user-config (json-parse-string user-config-str
                                                                       :object-type 'alist
                                                                       :array-type 'list))
                                       (workspace (alist-get 'workspace user-config)))
                                   (setq exercism--workspace workspace)))))
#+end_src

* flycheck

** Keybindings

| Keybind | Description   |
| ] e     | Next error    |
| [ e     | Prevous error |

#+begin_src elisp
(map! :leader
      :prefix ("e". "edit")
      :desc "list errors"    :n "l" #'flycheck-list-errors
      :desc "check buffer"   :n "c" #'flycheck-buffer
      :desc "select checker" :n "s" #'flycheck-select-checker
      :desc "flycheck setup" :n "v" #'flycheck-verify-setup)
#+end_src

** Disable LSP

#+begin_src elisp
(defun +config:flycheck-disable-lsp ()
  (setq flycheck-disabled-checkers '(lsp)))
(add-hook! prog-mode #'+config:flycheck-disable-lsp)
(add-hook! text-mode #'+config:flycheck-disable-lsp)
(add-hook! org-mode #'+config:flycheck-disable-lsp)
#+end_src

* folding

Use tab to fold in prog modes.

#+begin_src elisp
(defun +config:tab-to-fold-in-normal-state ()
  "Bind toggle-fold function to the <tab> key."
  (evil-local-set-key 'normal (kbd "<tab>") #'evil-toggle-fold))

(add-hook! prog-mode #'+config:tab-to-fold-in-normal-state)
#+end_src

* formatting

#+begin_src elisp
(setq +format-on-save-enabled-modes
      '(not js2-mode
            rjsx-mode
            typescript-mode
            emacs-lisp-mode  ; elisp's mechanisms are good enough
            sql-mode         ; sqlformat is currently broken
            tex-mode         ; latexindent is broken
            latex-mode))
#+end_src

Disable LSP formatting

#+begin_src elisp
(setq +format-with-lsp nil)
#+end_src

Enable prettier-js

#+begin_src elisp
(require 'prettier-js)
#+end_src

* gtags

** gxref

#+begin_src elisp
(setq xref-backend-functions '(elisp--xref-backend etags--xref-backend))
(add-to-list 'xref-backend-functions #'gxref-xref-backend)
#+end_src

** ggtags

https://github.com/leoliu/ggtags

#+begin_src elisp
(after! ggtags
  (ggtags-mode)
  (add-to-list 'xref-backend-functions #'ggtags-xref-backend))
#+end_src

#+begin_src elisp
(setq projectile-tags-command "global -u")
#+end_src

#+begin_src elisp
(defun project-gtags-refresh (arg)
  "Refresh the tags at project root, building tag files if in a project.
If the prefix arg ARG is passed, delete the tags at project root."
  (interactive "P")
  (if-let ((ggtags-project-root (projectile-acquire-root)))
      (if arg
          (ggtags-delete-tags)
        (if (file-exists-p (format "%s/GTAGS" ggtags-project-root))
            (ggtags-update-tags t)
          (ggtags-create-tags ggtags-project-root)))
    (message "Could not find a project root.")))

(map! :leader
      :prefix "p"
      :desc "regenerate tags"
      "G" #'project-gtags-refresh)
#+end_src

* latex
** Configuration
#+begin_src elisp
(setq font-latex-fontify-script nil
      tex-fontify-script nil)
#+end_src

** Formatting

#+begin_src elisp
;; enable apheleia mode in LaTeX-mode
(add-hook! latex-mode
  (apheleia-mode +1))

(add-hook! LaTeX-mode
  (apheleia-mode +1))
#+end_src

#+begin_src elisp
(defun +LaTeX-math-mode (displaymode-p)
  "If in evil normal state, wrap the current WORD in math mode.
If in an evil visual state, wrap the current selection in math mode."
  (interactive "P")
  (if (or (point-on-empty-line-p)
          (evil-insert-state-p))
      (if displaymode-p
          (progn
            (insert "\\[\n\n\\]")
            (goto-char (- (point) 3))
            (insert "\t")
            (evil-insert 1))
      (progn
        (insert "\\(  \\)")
        (goto-char (- (point) 3))
        (evil-insert 1)))
    (let* ((selected-text
            (if (evil-visual-state-p)
                (string-trim (buffer-substring (mark) (point)))
              (progn
                (select-around-point-to-whitespace-or-delimiters)
                (string-trim (buffer-substring (mark) (point))))))
           (wrapped-text
            (if displaymode-p
                (format "\\[%s\\]" selected-text)
              (format "\\(%s\\)" selected-text))))
      (progn
        (kill-region (mark) (point))
        (insert wrapped-text)))))
#+end_src

#+begin_src elisp
(defun +LaTeX-make-bold ()
  (interactive)
  (+LaTeX-wrap-in-cmd "textbf"))

(defun +LaTeX-make-italic ()
  (interactive)
  (+LaTeX-wrap-in-cmd "textit"))

(defun +LaTeX-make-underlined ()
  (interactive)
  (+LaTeX-wrap-in-cmd "underline"))

(defun +LaTeX-boxed ()
  (interactive)
  (+LaTeX-wrap-in-cmd "boxed"))

(defun +LaTeX-in-SI-units ()
  "Format the selected text with SI units in the buffer."
  (interactive)
  (let* ((selection (buffer-substring-no-properties (region-beginning) (region-end)))
         (split-pos (string-match " " selection)))
    (let ((formatted-string
           (if split-pos
               (let ((value (substring selection 0 split-pos))
                     (unit (substring selection (1+ split-pos))))
                 (format "\\SI{%s}{\\%s}" value unit))
             (format "\\SI{}{\\%s}" selection))))
      (delete-region (region-beginning) (region-end))
      (insert formatted-string))))
#+end_src

** Utilities

*** evaluate selection mathematically

#+begin_src elisp
(defun +LaTeX-evaluate-selection ()
  "Evaluate the selected expression numerically, converting LaTeX to
  mathematical operators as needed."
  (interactive)
  (let* ((selected-text (string-trim (buffer-substring (mark) (point))))
         (replaced-text (replace-regexp-in-string "\\\\cdot" "*" selected-text))
         (replaced-text (replace-regexp-in-string "\\\\ln" "ln" replaced-text))
         (replaced-text (replace-regexp-in-string "\\\\pi" "3.14159" replaced-text))
         (replaced-text (replace-regexp-in-string "\\\\exp" "exp" replaced-text))
         (replaced-text (replace-regexp-in-string "\\\\L" "" replaced-text))
         (replaced-text (replace-regexp-in-string "\\\\R" "" replaced-text))
         (replaced-text (replace-regexp-in-string "\\\\SI{\\([^}]+\\)}{[^}]*}" "\\1" replaced-text))
         (replaced-text (replace-regexp-in-string "\\\\p{\\([^}]+\\)}" "(\\1)" replaced-text))
         (replaced-text (replace-regexp-in-string "\\\\frac{\\([^}]+\\)}{\\([^}]+\\)}" "((\\1)/(\\2))" replaced-text))
         (replaced-text (replace-regexp-in-string "\\\\dfrac{\\([^}]+\\)}{\\([^}]+\\)}" "((\\1)/(\\2))" replaced-text))
         (replaced-text (replace-regexp-in-string "\\\\sfrac{\\([^}]+\\)}{\\([^}]+\\)}" "((\\1)/(\\2))" replaced-text))
         (replaced-text (replace-regexp-in-string "{" "(" replaced-text))
         (replaced-text (replace-regexp-in-string "}" ")" replaced-text))
         (replaced-text (replace-regexp-in-string "\\[" "(" replaced-text))
         (replaced-text (replace-regexp-in-string "\\]" ")" replaced-text))
         (result (calc-eval replaced-text)))
    (progn
      (message (format "Evaluating: %s = %s" replaced-text result))
      (kill-region (mark) (point))
      (insert (format "%s" result)))))
#+end_src

*** point-on-empty-line-p

#+begin_src elisp
(defun point-on-empty-line-p ()
  "Return t if the point is on an empty line, nil otherwise."
  (interactive)
  (save-excursion
    (beginning-of-line)
    (looking-at-p "^\\s-*$")))
#+end_src

*** make selection between whitespace/delimiters

#+begin_src elisp
(defun select-around-point-to-whitespace-or-delimiters ()
  "Select characters around the current point up to whitespace in both directions."
  (interactive)
  (let ((start (point))
        (end (point)))
    ;; Move start backward to the first whitespace or beginning of the buffer
    (while (and (not (bobp))
                (not (looking-back "\\s-\\|\n"))
                (not (looking-back "[,;=]")))
      (backward-char))
    (setq start (point))

    ;; Move end forward to the first whitespace or end of the buffer
    (goto-char end)
    (while (and (not (eobp))
                (not (looking-at "\\s-\\|\n"))
                (not (looking-at "[,;.]")))
      (forward-char))
    (setq end (point))

    ;; Select the region
    (set-mark start)
    (goto-char end)
    (activate-mark)))
#+end_src

*** wrap in command

#+begin_src elisp
(defun +LaTeX-wrap-in-cmd (cmd)
  (interactive "sCommand: ")
  (let ((selected-text
         (if (evil-visual-state-p)
             (string-trim (buffer-substring (mark) (point)))
           (progn
             (select-around-point-to-whitespace-or-delimiters)
             (string-trim (buffer-substring (mark) (point)))))))
    (progn
      (kill-region (mark) (point))
      (insert (format "\\%s{%s}" cmd selected-text)))))
#+end_src

** Keybindings

#+begin_src elisp
(map! :map (LaTeX-mode-map latex-mode-map)
      :nv  "s-b" #'+LaTeX-make-bold
      :nv  "s-i" #'+LaTeX-make-italic
      :nv  "s-u" #'+LaTeX-make-underlined
      :nvi "C-l" #'+LaTeX-math-mode
      :nvi "C-S-l" #'(lambda () (interactive) (+LaTeX-math-mode t))
      :ni  "s-c" #'+LaTeX-build-cleanup
      :ni  "s-<return>" #'+LaTeX-open-doc
      :ni  "s-S-<return>" #'(lambda () (interactive) (+LaTeX-open-doc t))
      :ni  "s-s" #'+LaTeX-save-and-compile)
#+end_src

** PDF auto-revert

#+begin_src elisp
(defun refresh-pdf-buffer-display ()
  "Refresh the display of the PDF buffer."
  (when (and (eq major-mode 'pdf-view-mode)
             (not (eq (current-buffer) (window-buffer (selected-window)))))
    (pdf-view-revert-buffer nil t)))

(defun auto-revert-mode-pdf-view-refresh ()
  "Enable auto-revert-mode and refresh display for PDF buffers."
  (add-hook 'auto-revert-hook 'refresh-pdf-buffer-display nil t))

(setq auto-revert-interval 1)
(setq auto-revert-verbose nil)

(add-hook! pdf-view-mode #'auto-revert-mode-pdf-view-refresh)
(add-hook! pdf-view-mode #'auto-revert-mode)
#+end_src

** Notes and Problem Sets
*** Find associated document

#+begin_src elisp
(defun +LaTeX-find-associated-doc (&optional filetype)
  "If not at the project root, take the main doc's name from the current directory.
Otherwise, assume the current file is the main doc."
  (interactive)
  (let* ((filetype (or filetype "tex"))
         (proj-root (projectile-project-root))
         (at-proj-root (string= default-directory proj-root))
         (doc-name (if (not at-proj-root)
                       (nth 1 (reverse (file-name-split default-directory)))
                     (file-name-base)))
         (history
          (mapcar #'file-name-sans-extension
                  (cl-remove-if-not
                   (lambda (fn) (message fn) (string-suffix-p (format ".%s" filetype) fn))
                   (directory-files proj-root nil (format "\.%s" filetype)))))
         (cl-first (car history))
         (cl-rest (cdr history)))
    (if (not (file-exists-p (format "%s/%s.%s" proj-root doc-name filetype)))
        (string-trim (read-from-minibuffer "file: " first nil nil 'rest))
      doc-name)))
#+end_src

*** Compile TeX

#+begin_src elisp
(defun +LaTeX-save-and-compile ()
  (interactive)
  (if (not (string= "tex" (file-name-extension (buffer-file-name))))
      (save-buffer)
    (let* ((shell-command-prompt-show-cwd t)
           (file-name (+LaTeX-find-associated-doc))
           (default-directory (projectile-project-root))
           (command (format "xelatex -shell-escape -interaction=nonstopmode -halt-on-error %s.tex" file-name)))
      (progn
        (save-buffer)
        (+async-shell-command-below command nil 0.05)))))
#+end_src

*** Clean up build artifacts

#+begin_src elisp
(defun +LaTeX-build-cleanup ()
  "Remove all aux, log, and out files in the project."
  (interactive)
  (let ((default-directory (projectile-project-root)))
    (+async-shell-command-below "rm -f *.{aux,log,out}" nil 0.3)))
#+end_src

*** Open PDF

#+begin_src elisp
(defun +LaTeX-open-doc (arg)
  (interactive "P")
  (let ((file-name (+LaTeX-find-associated-doc "pdf"))
        (default-directory (projectile-project-root)))
    (if arg
        (call-process-shell-command (format "open -a Skim.app %s.pdf" file-name))
      (+open-file-in-new-buffer-right (format "%s.pdf" file-name)))))
#+end_src

#+begin_src elisp
(defun +LaTeX-open-with-skim ()
  (interactive)
  (+LaTeX-open-doc t))
#+end_src

* lookup

** web searches

Use xwidgets to browse online search results online.

#+begin_src elisp
(setq +lookup-open-url-fn #'+lookup-xwidget-webkit-open-url-fn)
#+end_src


** dash-at-point

https://github.com/stanaka/dash-at-point

Lookup Dash docs quickly from the normal state.

#+begin_src elisp
(map! :map (emacs-lisp-mode-map org-mode-map)
      :nv "H" #'helpful-at-point)

(map! :map prog-mode-map
      :nv "H" #'dash-at-point)
#+end_src

Un-define doom's Dash-related functions since they're not installed.

#+begin_src elisp
(fmakunbound '+lookup:dash)
(fmakunbound '+lookup/in-docsets)
(fmakunbound '+lookup/in-all-docsets)
#+end_src

* lsp

https://emacs-lsp.github.io/lsp-mode

#+begin_src elisp
(after! (:all company lsp-mode)
  (require 'company-lsp)
  (push 'company-lsp company-backends))

(after! lsp-mode
  (use-package lsp-ui)
  (require 'lsp-ui))
#+end_src

#+begin_src elisp
(after! lsp-ui
  (setq lsp-enable-file-watchers nil
        lsp-keymap-prefix nil
        lsp-idle-delay 0.500
        lsp-prefer-capf t
        lsp-ui-doc-alignment 'frame
        lsp-ui-doc-delay 0.2
        lsp-ui-doc-enable nil
        lsp-ui-doc-header nil
        lsp-ui-doc-include-signature t
        lsp-ui-doc-position 'at-point
        lsp-ui-doc-use-childframe t
        lsp-ui-doc-use-webkit nil
        lsp-ui-sideline-enable nil
        lsp-ui-sideline-ignore-duplicate t
        lsp-ui-sideline-show-symbol t
        read-process-output-max (* 1024 1024)))
#+end_src

Register client for web-mode

#+begin_src elisp
(after! lsp-mode
  (lsp-register-client
   (make-lsp-client
    :new-connection (lsp-stdio-connection
                     (lambda ()
                       (cons (lsp-package-path 'html-language-server) lsp-html-server-command-args)))
    :major-modes '(web-mode)
    :priority -4
    :completion-in-comments? t
    :server-id 'html-ls
    :initialized-fn (lambda (w)
                      (with-lsp-workspace w
                        (lsp--set-configuration
                         (lsp-configuration-section "html"))))
    :download-server-fn (lambda (_client callback error-callback _update?)
                          (lsp-package-ensure
                           'html-language-server callback
                           error-callback))))
  nil)
(after! lsp-mode
  (progn
    (add-to-list 'lsp-language-id-configuration '(".*\\.html\\..+$" . "html"))
    (add-to-list 'lsp-language-id-configuration '(".*\\.js\\..+$" . "javascript"))
    (add-to-list 'lsp-language-id-configuration '(".*\\.css\\..+$" . "css"))
    nil))
#+end_src

* magit

https://magit.vc/manual/magit.html

#+begin_src elisp
(map! :desc "Open magit" "s-g" #'magit-status)
#+end_src

Remove the git flow hook added by doom.

#+begin_src elisp
(remove-hook! magit-mode #'turn-on-magit-gitflow)
#+end_src

* magit: time tracking

#+begin_src elisp
(defun magit-clock-in ()
  "Clock in with Magit, reading a commit subject line from user input."
  (interactive)
  (let ((subject-line (read-string "Task: ")))
    (magit-run-git-with-editor "clock-in" subject-line)))

(defun magit-clock-out ()
  "Clock out with Magit, opening the commit editor to finalize changes."
  (interactive)
  (magit-run-git-with-editor "clock-out-with-editor"))

(after! magit
  (transient-insert-suffix 'magit-commit "c" '("i" "Clock In" magit-clock-in))
  (transient-insert-suffix 'magit-commit "c" '("o" "Clock Out" magit-clock-out)))
#+end_src

#+begin_src elisp
(defun git-clock-in ()
  "Clock in with Git, reading a commit subject line from user input."
  (interactive)
  (when-let ((subject-line (read-string "Task: ")))
    (shell-command-to-string (format "git-clock-in %s" subject-line))))

(defun git-clock-out ()
  "Clock out with Git, committing all changed and new files in the working tree."
  (interactive)
  (shell-command-to-string (format "git add --all && git-clock-out")))

(map! :map prog-mode-map
      "s-c" #'git-clock-in
      "s-C" #'git-clock-out)
#+end_src

* magit: tagged commits

#+begin_src elisp
(defun magit-commit-tagged ()
  "Clock in with Magit, reading a commit subject line from user input."
  (interactive)
  (let ((subject-line (read-string "Message: ")))
    (magit-run-git-with-editor "commit-tagged" (split-string subject-line))))

(after! magit
  (transient-insert-suffix 'magit-commit "c" '("t" "Tagged" magit-commit-tagged)))
#+end_src
* markdown

** gfm-mode
Default to github-flavored markdown
#+begin_src elisp
(add-to-list 'auto-mode-alist '("\\.md\\'" . gfm-mode))
#+end_src
** keybindings

Clear pre-installed keymaps and set cleaned up keymaps.

#+begin_src elisp
(defun +config:keybindings:markdown ()
  (defvar markdown-mode-style-map (make-sparse-keymap))
  (defvar markdown-mode-command-map (make-sparse-keymap))
  (defvar markdown-mode-map (make-sparse-keymap))
  (defvar markdown-mode-mouse-map (make-sparse-keymap))

  (map! :map markdown-mode-map
        :ni "C-j" #'markdown-next-visible-heading
        :ni "C-k" #'markdown-previous-visible-heading)

  (map! :map markdown-mode-map
        :localleader
        :desc "edit code block"     :n "'"  #'markdown-edit-code-block
        :desc "export"              :n "e"  #'markdown-export
        :desc "open"                :n "o"  #'markdown-open
        :desc "gfm-preview"         :n "p"  #'+gfm-preview
        :desc "markdown-preview"    :n "P"  #'markdown-preview
       (:prefix ("h" . "header")
        :desc "dwim"                :nv "h"  #'markdown-insert-header-setext-dwim
        :desc "dwim (atx)"          :nv "H"  #'markdown-insert-header-dwim
        :desc "h1"                  :nv "1"  #'markdown-insert-header-setext-1
        :desc "h2"                  :nv "2"  #'markdown-insert-header-setext-2
        :desc "h3"                  :nv "3"  #'markdown-insert-header-atx-3
        :desc "h4"                  :nv "4"  #'markdown-insert-header-atx-4
        :desc "h5"                  :nv "5"  #'markdown-insert-header-atx-5
        :desc "h6"                  :nv "6"  #'markdown-insert-header-atx-6)
       (:prefix ("i" . "insert")
        :desc "bold"                :nv "b"  #'markdown-insert-bold
        :desc "code (gfm)"          :nv "c"  #'markdown-insert-gfm-code-block
        :desc "code"                :nv "C"  #'markdown-insert-code
        :desc "footnote"            :nv "f"  #'markdown-insert-footnote
        :desc "foldable block"      :nv "F"  #'markdown-insert-foldable-block
        :desc "italic"              :nv "i"  #'markdown-insert-italic
        :desc "kbd"                 :nv "k"  #'markdown-insert-kbd
        :desc "link"                :nv "l"  #'markdown-insert-link
        :desc "pre"                 :nv "p"  #'markdown-insert-pre
        :desc "pre block"           :nv "P"  #'markdown-pre-region
        :desc "quote"               :nv "q"  #'markdown-insert-blockquote
        :desc "quote block"         :nv "Q"  #'markdown-blockquote-region
        :desc "strikethrough"       :nv "s"  #'markdown-insert-strike-through
        :desc "table"               :nv "t"  #'markdown-insert-table
        :desc "table of contents"   :nv "T"  #'markdown-toc-generate-or-refresh-toc
        :desc "wiki link"           :nv "w"  #'markdown-insert-wiki-link
        :desc "hr"                  :nv "-"  #'markdown-insert-hr
        :desc "checkbox (gfm)"      :nv "["  #'markdown-insert-gfm-checkbox)
       (:prefix ("t" . "table")
        :desc "sort lines"          :nv "s"  #'markdown-table-sort-lines
        :desc "convert region"      :nv "v"  #'markdown-table-convert-region
        :desc "transpose"           :n  "t"  #'markdown-table-transpose
        :desc "row delete"          :n  "R"  #'markdown-table-delete-row
        :desc "row insert"          :n  "r"  #'markdown-table-insert-row
        :desc "column delete"       :n  "C"  #'markdown-table-delete-column
        :desc "column insert"       :n  "c"  #'markdown-table-insert-column))
  nil)

(after! markdown-mode
  (remove-hook! markdown-mode #'doom--enable-+javascript-npm-mode-in-markdown-mode-h)
  (add-hook! markdown-mode :append #'+config:keybindings:markdown))
#+end_src

** =markdown-preview=: gfm-ish preview

#+begin_src elisp
(defun xwwp-browse-url (url &optional new-session)
  "Ask xwidget-webkit to browse URL.
NEW-SESSION specifies whether to create a new xwidget-webkit session.
Interactively, URL defaults to the string looking like a url around point."
  (interactive (progn
                 (require 'browse-url)
                 (browse-url-interactive-arg "xwidget-webkit URL: " (xwidget-webkit-current-url))))
  (or (featurep 'xwidget-internal)
      (user-error "Your Emacs was not compiled with xwidgets support"))
  (when (stringp url)
    (if new-session
        (xwidget-webkit-new-session url)
      (xwidget-webkit-goto-url url))))
#+end_src

#+begin_src elisp
(setq browse-url-browser-function #'xwwp-browse-url)
#+end_src

** =markdown-preview-gfm=: gfm preview with mathjax

#+begin_src elisp
(defun +gfm-preview ()
  "Preview markdown with direct HTML and MathJax rendering."
  (interactive)
  (let* ((markdown-content (buffer-string))
         (preview-file (concat temporary-file-directory "markdown-preview.html")))
    ;; Create a direct HTML file
    (with-temp-file preview-file
      (insert "<!DOCTYPE html>
<html>
<head>
<meta charset=\"utf-8\">
<title>Markdown Preview</title>
<style>
body {
  padding: 20px;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
  line-height: 1.5;
  max-width: 980px;
  margin: 0 auto;
}
pre { background-color: #f6f8fa; padding: 16px; border-radius: 6px; overflow: auto; }
code { font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace; }
</style>
<!-- MathJax 3 -->
<script>
MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\\\(', '\\\\)']],
    displayMath: [['$$', '$$'], ['\\\\[', '\\\\]']],
    processEscapes: true
  }
};
</script>
<script id=\"MathJax-script\" async src=\"https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js\"></script>

<link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css\">
<script src=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js\"></script>
</head>
<body>
<textarea id=\"source\" style=\"display: none;\">")

      ;; Insert the raw markdown
      (insert markdown-content)

      (insert "</textarea>
<div id=\"content\"></div>

<script src=\"https://cdn.jsdelivr.net/npm/marked/marked.min.js\"></script>
<script>
// Configure marked
marked.setOptions({
  gfm: true,
  breaks: true,
  pedantic: false,
  sanitize: false,
  smartLists: true,
  smartypants: true,
  xhtml: false,
  highlight: function(code, lang) {
    if (lang && hljs.getLanguage(lang)) {
      return hljs.highlight(code, { language: lang }).value;
    }
    return hljs.highlightAuto(code).value;
  }
});

// Function to render markdown
function renderMarkdown() {
  var source = document.getElementById('source').value;

  // Pre-process LaTeX delimiters to protect them
  source = source
    // Protect display math
    .replace(/\\\\\\[/g, '%%%DISPLAY_MATH_START%%%')
    .replace(/\\\\\\]/g, '%%%DISPLAY_MATH_END%%%')
    // Protect inline math
    .replace(/\\\\\\(/g, '%%%INLINE_MATH_START%%%')
    .replace(/\\\\\\)/g, '%%%INLINE_MATH_END%%%');

  // Render markdown
  var html = marked.parse(source);

  // Restore LaTeX delimiters
  html = html
    .replace(/%%%DISPLAY_MATH_START%%%/g, '\\\\[')
    .replace(/%%%DISPLAY_MATH_END%%%/g, '\\\\]')
    .replace(/%%%INLINE_MATH_START%%%/g, '\\\\(')
    .replace(/%%%INLINE_MATH_END%%%/g, '\\\\)');

  document.getElementById('content').innerHTML = html;

  // Typeset math
  MathJax.typesetPromise().catch(function(err) {
    console.log('Error typesetting math: ' + err.message);
  });
}

// Render the markdown
renderMarkdown();
</script>

<script>hljs.highlightAll();</script>
</body>
</html>"))

    ;; Open the file in xwidget-webkit
    (xwwp-browse-url (concat "file://" preview-file))))
#+end_src

* org

https://orgmode.org/manual

** commands

#+begin_src elisp
(defun org-insert-heading-above ()
  "Insert heading above the current one."
  (interactive)
  (progn
    (org-back-to-heading)
    (move-beginning-of-line nil)
    (org-insert-heading)
    (evil-insert 1)))

(defun org-insert-heading-below ()
  "Insert heading below the current section."
  (interactive)
  (progn
    (org-insert-heading-respect-content nil)
    (evil-insert 1)))

(defun org-insert-subheading-below ()
  "Insert subheading below the current section."
  (interactive)
  (progn
    (org-next-visible-heading 1)
    (move-beginning-of-line nil)
    (org-insert-subheading nil)
    (evil-insert 1)))
#+end_src

** keybindings

See =lang/org/config.el= for doom's [[file:~/.dotfiles/share/emacs/modules/lang/org/config.el::1127][evil-org-mode]] and [[/Users/jmromer/.dotfiles/share/emacs/modules/lang/org/config.el::765][org-mode]] keybindings.

#+begin_src elisp
(after! org
  (setq org-M-RET-may-split-line nil
        org-insert-heading-respect-content nil)

  (defun +config:keybindings:org-mode ()
    (global-unset-key (kbd "s-RET"))
    (global-unset-key (kbd "s-<return>"))

    (map! :map org-mode-map
          "s-r" #'avy-org-refile-as-child)

    (map! :map evil-org-mode-map
          :n  "C-j"          #'org-next-visible-heading
          :n  "C-k"          #'org-previous-visible-heading
          :ni "s-RET"        #'org-insert-heading-below
          :ni "s-<return>"   #'org-insert-heading-below
          :ni "s-S-RET"      #'org-insert-heading-above
          :ni "s-S-<return>" #'org-insert-heading-above
          :ni "s-C-RET"      #'org-insert-subheading-below
          :ni "s-C-<return>" #'org-insert-subheading-below)

    (map! :map org-mode-map
          :localleader
          :desc "update statistics cookies"  "#"  #'org-update-statistics-cookies
          :desc "edit special"               "'"  #'org-edit-special
          :desc "C-c *"                      "*"  #'org-ctrl-c-star
          :desc "C-c -"                      "+"  #'org-ctrl-c-minus
          :desc "switch buffer"              ","  #'org-switchb
          :desc "goto heading"               "."  #'consult-org-heading
          :desc "goto agenda item"           "/"  #'consult-org-agenda
          :desc "archive subtree"            "A"  #'org-archive-subtree
          :desc "export dispatch"            "e"  #'org-export-dispatch
          :desc "footnote new"               "f"  #'org-footnote-new
          :desc "toggle heading"             "h"  #'org-toggle-heading
          :desc "toggle item"                "i"  #'org-toggle-item
          :desc "id get create"              "I"  #'org-id-get-create
          :desc "store link"                 "n"  #'org-store-link
          :desc "set-property"               "o"  #'org-set-property
          :desc "set-tags-command"           "q"  #'org-set-tags-command
          :desc "todo"                       "t"  #'org-todo
          :desc "todo list"                  "T"  #'org-todo-list
          :desc "toggle checkbox"            "x"  #'org-toggle-checkbox
          :desc "insert template"         :n "s" #'org-insert-structure-template))

  (add-hook! 'org-mode-hook :append #'+config:keybindings:org-mode))
#+end_src

** file paths

File paths for Org documents, Deft notes, and etc. Note that modifying
~org-directory~ must happen /before/ =org= has loaded.

#+begin_src elisp
(setq org-directory (getenv "ORG_HOME")
      deft-directory (format "%s/notes" org-directory))
#+end_src

#+begin_src elisp
(after! org
  (setq org-agenda-files (list org-directory)
        org-archive-location (concat  org-directory "/archive/%s::")
        org-default-notes-file (format "%s/notes.org" org-directory)
        ;; the following are relative to `org-directory', unless absolute.
        +org-capture-changelog-file "changelog.org"
        +org-capture-journal-file (format "%s/journal.org.gpg" org-directory)
        +org-capture-notes-file "notes.org"
        +org-capture-projects-file "projects.org"
        +org-capture-todo-file "todo.org"))
#+end_src

** capture templates

#+begin_src elisp
(after! org
 (setq +org-capture-frame-parameters
       '((name . "org-capture")
         (fullscreen . fullboth)
         (transient . t)
         (menu-bar-lines . 1))))
#+end_src

#+begin_src elisp
(after! org
  (setq org-capture-templates
        '(("t" "Personal todo" entry (file+headline +org-capture-todo-file "Inbox")
           "* [ ] %?\n%i\n%a" :prepend t)
          ("d" "Dev environment todo" entry (file+headline +org-capture-todo-file "Development Environment")
           "* [ ] %?\n%i\n%a" :prepend t)
          ("n" "Personal notes" entry (file+headline +org-capture-notes-file "Inbox")
           "* %u %?\n%i\n%a" :prepend t)
          ("j" "Journal" entry (file+olp+datetree +org-capture-journal-file)
           "* %U %?\n%i\n%a" :prepend t)

          ("b" "Blog Entries")
          ("bp" "Project" entry (file+headline "blog/projects.org" "Projects")
           (function org-hugo-new-project-capture-template) :empty-lines 1 :prepend t)
          ("bc" "Commonplace" entry (file+headline "blog/commonplaces.org" "Commonplaces")
           (function org-hugo-new-commonplace-capture-template) :empty-lines 1 :prepend t)
          ("bm" "Marginalia" entry (file+headline "blog/marginalia.org" "Marginalia")
           (function org-hugo-new-marginalia-capture-template) :empty-lines 1 :prepend t)
          ("bn" "Notes" entry (file+headline "blog/notebook.org" "Notes")
           (function org-hugo-new-project-capture-template) :empty-lines 1 :prepend t)
          ("bs" "Article Summary" entry (file+headline "blog/notebook.org" "Notes")
           (function org-hugo-new-summary-capture-template) :empty-lines 1 :prepend t)

          ;; Will use {project-root}/{todo,notes,changelog}.org, unless a
          ;; {todo,notes,changelog}.org file is found in a parent directory.
          ;; Uses the basename from `+org-capture-todo-file',
          ;; `+org-capture-changelog-file' and `+org-capture-notes-file'.
          ("p" "Templates for projects")
          ("pt" "Project-local todo" entry (file+headline +org-capture-project-todo-file "Inbox")
           "* TODO %?\n%i\n%a" :prepend t)
          ("pn" "Project-local notes" entry (file+headline +org-capture-project-notes-file "Inbox")
           "* %U %?\n%i\n%a" :prepend t)
          ("pc" "Project-local changelog" entry (file+headline +org-capture-project-changelog-file "Unreleased")
           "* %U %?\n%i\n%a" :prepend t)

          ;; Will use {org-directory}/{+org-capture-projects-file} and store
          ;; these under {ProjectName}/{Tasks,Notes,Changelog} headings. They
          ;; support `:parents' to specify what headings to put them under, e.g.
          ;; :parents ("Projects")
          ("o" "Centralized templates for projects")
          ("ot" "Project todo" entry (function +org-capture-central-project-todo-file)
           "* TODO %?\n %i\n %a" :heading "Tasks" :prepend nil)
          ("on" "Project notes" entry (function +org-capture-central-project-notes-file)
           "* %U %?\n %i\n %a" :heading "Notes" :prepend t)
          ("oc" "Project changelog" entry (function +org-capture-central-project-changelog-file)
           "* %U %?\n %i\n %a" :heading "Changelog" :prepend t))))
#+end_src

** variables

#+begin_src elisp
(setq org-adapt-indentation t
      org-agenda-block-separator ""
      org-agenda-start-with-log-mode t
      org-agenda-window-setup 'current-window
      org-blank-before-new-entry '((heading . auto) (plain-list-item . auto))
      org-catch-invisible-edits 'show-and-error
      org-confirm-babel-evaluate nil
      org-cycle-separator-lines 2
      org-edit-src-content-indentation 0
      org-ellipsis " ▾"
      org-fontify-done-headline t
      org-fontify-quote-and-verse-blocks t
      org-fontify-whole-heading-line t
      org-hide-emphasis-markers t
      org-image-actual-width 500
      org-list-use-circular-motion t
      org-log-done 'time
      org-log-into-drawer t
      org-outline-path-complete-in-steps nil
      org-pretty-entities t
      org-refile-allow-creating-parent-nodes 'confirm
      org-refile-use-outline-path 'file
      org-src-ask-before-returning-to-edit-buffer nil
      org-src-tab-acts-natively t
      org-src-window-setup 'current-window
      org-startup-folded 'overview
      org-startup-indented t
      org-startup-with-inline-images t
      org-tags-column 0)
#+end_src

** agenda files

#+begin_src elisp
(map! "s-," #'org-cycle-agenda-files)
(map! :map org-mode-map "C-'" nil)
#+end_src

** structure templates

#+begin_src elisp
(after! org
  (setq org-structure-template-alist
        '(
          ("c" . "cite")
          ("C" . "center")
          ("e" . "example")
          ("E" . "export")
          ("q" . "quote")
          ("s" . "src")
          ("se" . "src elisp")
          ("sj" . "src jsx")
          ("sp" . "src python")
          ("sr" . "src ruby")
          ("ss" . "src bash")
          ("st" . "src tsx")
          ("sx" . "src elixir")
          ("v" . "verse")
          )))
#+end_src

** org-appear

https://github.com/awth13/org-appear

#+begin_src elisp
(use-package! org-appear
  :after org
  :hook (org-mode . org-appear-mode)
  :config
  (setq org-appear-autoemphasis t
        org-appear-autolinks t
        org-appear-autosubmarkers t))
#+end_src

** org-journal

https://github.com/bastibe/org-journal

#+begin_src elisp
(setq org-journal-date-format "%A, %B %d %Y"
      org-journal-dir (format "%s/journal" (getenv "ORG_HOME"))
      org-journal-file-format "%Y%m%d"
      org-journal-file-type 'monthly
      org-journal-find-file #'find-file)
#+end_src

#+begin_src elisp
(defun org-journal-find-location ()
  "Open today's journal entry."
  ;; Open today's journal, but specify a non-nil prefix argument in order to
  ;; inhibit inserting the heading; org-capture will insert the heading.
  (org-journal-new-entry t)
  ;; Position point on the journal's top-level heading so that org-capture
  ;; will add the new entry as a child entry.
  (goto-char (point-max)))

(defun org-journal-today ()
  "Open today's journal."
  (interactive)
  (org-journal-find-location)
  (goto-char (point-max)))
#+end_src

** org-projectile

#+begin_src elisp
(setq org-projectile-projects-file
      (format "%s/projects.org" (getenv "ORG_HOME")))

(map! :leader
      :prefix "p"
      :desc "new project todo"
            "n" #'org-projectile-capture-for-current-project
      :desc "new project todo (select)"
            "N" #'org-projectile-project-todo-completing-read)
#+end_src

** ox-hugo

- https://ox-hugo.scripter.co
- https://github.com/kaushalmodi/ox-hugo

#+begin_src elisp
(after! ox
  (require 'ox-hugo))
#+end_src

#+begin_src elisp
(setq org-hugo-export-with-section-numbers nil
      org-hugo-export-with-toc nil)
#+end_src

*** org-hugo-headline patch

Fixes an issue where tags are displayed in headlines

#+begin_src elisp
(after! ox-hugo
  (defun org-hugo-headline (headline contents info)
    "Transcode HEADLINE element into Markdown format.
CONTENTS is the headline contents.  INFO is a plist used as
a communication channel."
    (unless (org-element-property :footnote-section-p headline)
      (let* ((numbers (org-hugo--get-headline-number headline info nil))
             (loffset (string-to-number (plist-get info :hugo-level-offset))) ;"" -> 0, "0" -> 0, "1" -> 1, ..
             (level (org-export-get-relative-level headline info))
             (level-effective (+ loffset level))
             (title (org-export-data (org-element-property :title headline) info)) ;`org-export-data' required
             (todo (and (org-hugo--plist-get-true-p info :with-todo-keywords)
                        (org-element-property :todo-keyword headline)))
             (todo-fmtd (when todo
                          (concat (org-hugo--todo todo info) " ")))
             (tags (and (org-hugo--plist-get-true-p info :with-tags)
                        (let ((tag-list (org-export-get-tags headline info)))
                          (and tag-list
                               (format "     :%s:"
                                       (mapconcat #'identity tag-list ":"))))))
             (priority
              (and (org-hugo--plist-get-true-p info :with-priority)
                   (let ((char (org-element-property :priority headline)))
                     (and char (format "[#%c] " char)))))
             (style (plist-get info :md-headline-style)))
        ;; (message "[ox-hugo-headline DBG] num: %s" numbers)
        (cond
         ;; Cannot create a headline.  Fall-back to a list.
         ((or (org-export-low-level-p headline info)
              (not (memq style '(atx setext)))
              (and (eq style 'atx) (> level-effective 6))
              (and (eq style 'setext) (> level-effective 2)))
          (let ((bullet
                 (if (not (org-export-numbered-headline-p headline info)) "-"
                   (concat (number-to-string
                            (car (last (org-export-get-headline-number
                                        headline info))))
                           ".")))
                (heading (concat todo-fmtd " " priority title))) ;Headline text without tags
            (concat bullet (make-string (- 4 (length bullet)) ?\s) heading tags "\n\n"
                    (and contents (replace-regexp-in-string "^" "    " contents)))))
         (t
          (let* ((anchor (format "{#%s}" ;https://gohugo.io/extras/crossreferences/
                                 (org-hugo--get-anchor headline info)))
                 (headline-title (org-hugo--headline-title style level loffset title todo-fmtd "" ""))
                 (content-str (or (org-string-nw-p contents) "")))
            (format "%s%s" headline-title content-str))))))))
#+end_src

*** ox-hugo capture template functions
**** timestamp helper

#+begin_src elisp
(defun hugo-timestamp ()
  "Return a timestamp in ISO 8601 format."
  (concat
   (format-time-string "%Y-%m-%dT%T")
   ((lambda (x) (concat (substring x 0 3) ":" (substring x 3 5)))
    (format-time-string "%z"))))
#+end_src

**** projects
#+begin_src elisp
(defun org-hugo-new-project-capture-template ()
  "Return `org-capture' template string for new Hugo blog post.
See `org-capture-templates' for more information."
  (save-match-data
    (let ((date (format-time-string "%Y-%m-%d" (current-time)))
          (timestamp (hugo-timestamp))
          (title (read-from-minibuffer "Project: " ""))
          (summary (read-from-minibuffer "Summary: " "")))
      (mapconcat #'identity
                 `(
                   ,(concat "* DRAFT " title)
                   ":PROPERTIES:"
                   ,(concat ":EXPORT_FILE_NAME: " date "-" (org-hugo-slug title))
                   ,(concat ":EXPORT_DATE: " timestamp)
                   ,(concat ":EXPORT_HUGO_CUSTOM_FRONT_MATTER: :toc true :summary " summary)
                   ":END:"
                   "%?\n")
                 "\n"))))
#+end_src

**** article summaries
#+begin_src elisp
(defun org-hugo-new-summary-capture-template ()
  "Return `org-capture' template string for new Hugo blog post.
See `org-capture-templates' for more information."
  (save-match-data
    (let ((date (format-time-string "%Y-%m-%d" (current-time)))
          (timestamp (hugo-timestamp))
          (title (read-from-minibuffer "Title: " ""))
          (summary (read-from-minibuffer "Summary: " "")))
      (mapconcat #'identity
                 `(
                   ,(concat "* DRAFT " title)
                   ":PROPERTIES:"
                   ,(concat ":EXPORT_FILE_NAME: " date "-" (org-hugo-slug title))
                   ,(concat ":EXPORT_DATE: " timestamp)
                   ,(concat ":EXPORT_HUGO_CUSTOM_FRONT_MATTER: :toc true :summary " summary)
                   ":END:"
                   "#+begin_cite"
                   "%?"
                   "#+end_cite"
                   "** The New Hotness"
                   "** Key Insight"
                   "** How It Works"
                   "** Results"
                   "** The Backstory"
                   "** Why It Matters")
                 "\n"))))
#+end_src

**** marginalia

#+begin_src elisp
(defun org-hugo-new-marginalia-capture-template ()
  "Return `org-capture' template string for new Hugo marginalia post.
See `org-capture-templates' for more information."
  (save-match-data
    (let ((timestamp (hugo-timestamp))
          (date (format-time-string "%Y-%m-%d" (current-time)))
          (title (read-from-minibuffer "Description: " "")))
      (mapconcat #'identity
                 `(
                   ,(concat "* " title)
                   ":PROPERTIES:"
                   ,(concat ":EXPORT_FILE_NAME: " date "-" (org-hugo-slug title))
                   ,(concat ":EXPORT_DATE: " timestamp)
                   ":END:"
                   "%?\n")
                 "\n"))))
#+end_src

**** commonplaces

#+begin_src elisp
(defun org-hugo-new-commonplace-capture-template ()
  "Return `org-capture' template string for new Hugo commonplace post.
See `org-capture-templates' for more information."
  (save-match-data
    (let ((title (read-from-minibuffer "Title: "))
          (desc (read-from-minibuffer "Description: "))
          (author (read-from-minibuffer "Author: "))
          (source (read-from-minibuffer "Source Title: "))
          (cite (read-from-minibuffer "Citation Date: "))
          (url (read-from-minibuffer "Source URL: "))
          (timestamp (hugo-timestamp))
          (type (car (cdr  (read-multiple-choice
                            "Source Type: "
                            '((?b "book" "Book / Magazine / Film / Album")
                              (?a "article" "Blog post / Article / Essay")
                              (?p "poem" "Poem")
                              (?t "tweet" "Tweet")))))))
      (mapconcat #'identity
                 `(
                   ,(concat "* " title)
                   ":PROPERTIES:"
                   ,(concat ":EXPORT_FILE_NAME: " (org-hugo-slug title))
                   ,(concat ":EXPORT_AUTHOR: " author)
                   ,(concat ":EXPORT_DATE: " timestamp)
                   ,(concat ":EXPORT_HUGO_CUSTOM_FRONT_MATTER: "
                            ":source " source
                            " :cite " cite
                            " :type " type
                            " :sourceurl " url)
                   ,(concat ":EXPORT_DESCRIPTION: " desc)
                   ":END:"
                   "%?\n")
                 "\n"))))
#+end_src

*** +org-hugo-export-all

#+begin_src elisp
;;;###autoload
(defun +org-hugo-export-all (&optional dir)
  "Export every Hugo-ready subtree in all .org files under DIR."
  (let ((dir    (expand-file-name (or dir default-directory)))
        (files  (directory-files-recursively dir "\\.org$")))
    (dolist (f files)
      (with-temp-buffer
        (insert-file-contents f)
        (org-mode)
        (message "→ %s" f)
        (org-element-map (org-element-parse-buffer) 'headline
          (lambda (hl)
            (when (org-element-property :EXPORT_DATE hl)
              (goto-char (org-element-property :begin hl))
              (org-hugo-export-wim-to-md t))))))))
#+end_src

** avy

#+begin_src elisp
(use-package! avy
  :after org
  :hook (org-mode . avy-setup-default))
#+end_src

* projectile

#+begin_src elisp
(map! :map prog-mode-map
      :desc "toggle test/implementation"
      :n ", ," #'projectile-toggle-between-implementation-and-test)
#+end_src

Default to searching projects with an invalidated cache.

#+begin_src elisp :tangle no
(map! :leader
      :prefix "p"
      :desc "find file in project"
      :n "f" #'(lambda () (interactive) (projectile-find-file-dwim t))
      :desc "find file in project (with cache)"
      :n "F" #'projectile-find-file-dwim)
#+end_src

#+begin_src elisp
(setq projectile-project-search-path
      '(("~/.dotfiles/share" . 2)
        ("~/Projects" . 1)
        ("~/Courses" . 2)
        ("~/iCloud/Courses" . 2)
        ("~/Work" . 2)
        ("~/Writing" . 2)))
#+end_src

#+begin_src elisp
(setq projectile-create-missing-test-files t)
#+end_src

#+begin_src elisp
(setq projectile-switch-project-action #'projectile-dired)
#+end_src

* python

** projectile

Add Python project types: Pipenv, Poetry, Pytest

#+begin_src elisp
(after! projectile
  (projectile-register-project-type 'python-pipenv
                                    '("Pipfile")
                                    :compile "pipenv run compile"
                                    :test "pipenv run test"
                                    :test-suffix "_test")

  (projectile-register-project-type 'python-pytest
                                    '(".pytest_cache")
                                    :compile "pytest"
                                    :test "pytest"
                                    :test-prefix "test_"
                                    :test-suffix "_test")

  (projectile-register-project-type 'python-poetry
                                    '("pyproject.toml")
                                    :compile ""
                                    :test "poetry run pytest"
                                    :test-prefix "test_"
                                    :test-suffix "_test"))
#+end_src

** pipenv

#+begin_src elisp
(map! :map python-mode-map
      :localleader
      :prefix ("e" . "pipenv")
      :desc "activate"    :n "a"   #'pipenv-activate
      :desc "deactivate"  :n "d"   #'pipenv-deactivate
      :desc "install"     :n "i"   #'pipenv-install
      :desc "lock"        :n "l"   #'pipenv-lock
      :desc "open module" :n "o"   #'pipenv-open
      :desc "run"         :n "r"   #'pipenv-run
      :desc "shell"       :n "s"   #'pipenv-shell
      :desc "uninstall"   :n "u"   #'pipenv-uninstall)
#+end_src

** pyvenv

#+begin_src elisp
(map! :map python-mode-map
      :localleader
      :prefix ("v" . "virtualenv")
      :desc "activate"       :n "a" #'pyvenv-activate-venv-dwim
      :desc "deactivate"     :n "d" #'pyvenv-deactivate
      :desc "restart python" :n "r" #'pyvenv-restart-python)
#+end_src

#+begin_src elisp
(defun pyvenv-activate-venv-dwim ()
  "Activate the virtualenv at project root, if one can be found.
If it can't, delegate to `pyvenv-activate', which will prompt for a path."
  (interactive)
  (let* ((proj-root (projectile-project-root))
         (dir (when proj-root (concat proj-root "env/")))
         (env (when (and dir (file-exists-p dir)) dir))
         (dir (when proj-root (concat proj-root "venv/")))
         (venv (when (and dir (file-exists-p dir)) dir))
         (dir (when proj-root (concat proj-root ".env/")))
         (denv (when (and dir (file-exists-p dir)) dir))
         (dir (when proj-root (concat proj-root ".venv/")))
         (dvenv (when (and dir (file-exists-p dir)) dir)))
    (if-let ((virtualenv (or env venv denv dvenv)))
        (progn
          (message (format "activating virtualenv at %s" (abbreviate-file-name virtualenv)))
          (pyvenv-activate virtualenv))
      (call-interactively #'pyvenv-activate))))
#+end_src

** pytest

Unbind conflicting keybindings.

#+begin_src elisp
(global-unset-key (kbd "s-RET"))
(global-unset-key (kbd "s-<return>"))
(global-unset-key (kbd "s-S-RET"))
(global-unset-key (kbd "s-S-<return>"))
#+end_src

Bind test-running keybindings.

#+begin_src elisp
(map! :map python-mode-map
      :ni "s-<return>"   #'python-pytest-file
      :ni "s-RET"        #'python-pytest-file
      :ni "s-C-<return>" #'python-pytest-window-delete
      :ni "s-C-RET"      #'python-pytest-window-delete
      :ni "s-S-<return>" #'python-pytest-repeat
      :ni "s-S-RET"      #'python-pytest-repeat)

(map! :after python
      :map python-mode-map
      :localleader
      :prefix ("t" . "pytest")
      :desc "single"      :n "t" #'python-pytest-function-dwim
      :desc "all"         :n "a" #'python-pytest
      :desc "buffer"      :n "b" #'python-pytest-file-dwim
      :desc "file"        :n "f" #'python-pytest-file
      :desc "last"        :n "l" #'python-pytest-repeat
      :desc "last failed" :n "L" #'python-pytest-last-failed
      :desc "close"       :n "c" #'python-pytest-window-delete
      :desc "dispatch"    :n "." #'python-pytest-dispatch
      "F" nil
      "T" nil
      "p" nil
      "r" nil)
#+end_src

kill any open pytest compilation buffers

#+begin_src elisp
(defun window-with-name-prefix-delete (prefix)
  "Delete the first matching window with the given name PREFIX."
  (delete-window
   (get-buffer-window
    (seq-find
     #'(lambda (buffer) (string-prefix-p prefix (buffer-name buffer)))
     (buffer-list)))))

(defun python-pytest-window-delete ()
  "Delete the pytest compilation windows."
  (interactive)
  (window-with-name-prefix-delete "*pytest*"))
#+end_src

** repl

#+begin_src elisp
(setq +eval-repls '((sh-mode +sh/open-repl)
                    (python-mode +python/open-jupyter-repl :persist t :send-region python-shell-send-region :send-buffer python-shell-send-buffer)
                    (lisp-interaction-mode +emacs-lisp/open-repl)))
#+end_src

* react & web

Use =rjsx-mode= for React and React-TypeScript files.

#+begin_src elisp
(setq auto-mode-alist
      (assoc-delete-all
       "\\.tsx\\'"
       (assoc-delete-all
        "\\.jsx\\'"
        auto-mode-alist)))

(add-to-list 'auto-mode-alist '("\\.\\(?:jsx\\|tsx\\)\\'" . rjsx-mode))
#+end_src

** Emmet

Use =C-RET= to expand emmet tags.

#+begin_src elisp
(defun +config:keybindings:web ()
  (map! :ni "C-<return>" #'emmet-expand-line))

(add-hook! '(web-mode-hook rjsx-mode-hook) #'+config:keybindings:web)
#+end_src

Emmet should expand classes as =className= in JSX modes.

#+begin_src elisp
(defun +config:emmet-expand-jsx-classname ()
  (setq emmet-expand-jsx-className? t))

(add-hook! '(rjsx-mode-hook typescript-tsx-mode-hook) #'+config:emmet-expand-jsx-classname)
#+end_src

* ruby

** keybindings

Set descriptions for prefixes and commands to aid discoverability.

#+begin_src elisp
(defun +config:keybindings:ruby ()
  (map! :localleader :map robe-mode-map "'" nil "h" nil "R" nil)
  (map! :localleader :map rubocop-mode-map "f" nil "F" nil "p" nil "P" nil)
  (map! :localleader :map ruby-mode-map "{" nil)
  (map! :localleader
        :map ruby-mode-map
        :desc "toggle block"          "["  #'ruby-toggle-block
        (:prefix ("'" . "robe")
         :desc "start"                "'"  #'robe-start
         :desc "doc"                  "h"  #'robe-doc
         :desc "rails refresh"        "r"  #'robe-rails-refresh)
        (:prefix ("f" . "rubocop")
         :desc "check file"           "f"  #'rubocop-check-current-file
         :desc "autocorrect file"     "F"  #'rubocop-autocorrect-current-file
         :desc "check project"        "p"  #'rubocop-check-project
         :desc "autocorrect project"  "P"  #'rubocop-autocorrect-project)
        (:prefix ("s" . "send to repl")
         :desc "definition"           "d"  #'ruby-send-definition
         :desc "definition & go"      "D"  #'ruby-send-definition-and-go
         :desc "region"               "r"  #'ruby-send-region
         :desc "region & go"          "R"  #'ruby-send-region-and-go
         :desc "switch to inf"        "i"  #'ruby-switch-to-inf)))

(add-hook! ruby-mode #'+config:keybindings:ruby)
#+end_src

#+begin_src elisp
;; clear projectile-rails's keybinds
(defun +config:keybindings:rails ()
  (map! :localleader :map projectile-rails-mode-map "r" nil)
  (map! :localleader
        :map ruby-mode-map
       (:prefix ("r" . "rails")
        :desc "model"                 "m"   #'projectile-rails-find-model
        :desc "model (current)"       "M"   #'projectile-rails-find-current-model
        :desc "controller"            "c"   #'projectile-rails-find-controller
        :desc "controller (current)"  "C"   #'projectile-rails-find-current-controller
        :desc "view"                  "v"   #'projectile-rails-find-view
        :desc "view (current)"        "V"   #'projectile-rails-find-current-view
        :desc "js"                    "j"   #'projectile-rails-find-javascript
        :desc "js (current)"          "J"   #'projectile-rails-find-current-javascript
        :desc "styles"                "s"   #'projectile-rails-find-stylesheet
        :desc "styles (current)"      "S"   #'projectile-rails-find-current-stylesheet
        :desc "helper"                "h"   #'projectile-rails-find-helper
        :desc "helper (current)"      "H"   #'projectile-rails-find-current-helper
        :desc "spec"                  "p"   #'projectile-rails-find-spec
        :desc "spec (current)"        "P"   #'projectile-rails-find-current-spec
        :desc "test"                  "t"   #'projectile-rails-find-test
        :desc "test (current)"        "T"   #'projectile-rails-find-current-test
        :desc "migration"             "n"   #'projectile-rails-find-migration
        :desc "migration (current)"   "N"   #'projectile-rails-find-current-migration
        :desc "fixture"               "u"   #'projectile-rails-find-fixture
        :desc "fixture (current)"     "U"   #'projectile-rails-find-current-fixture
        :desc "component"             "w"   #'projectile-rails-find-component
        :desc "lib"                   "l"   #'projectile-rails-find-lib
        :desc "feature"               "f"   #'projectile-rails-find-feature
        :desc "initializer"           "i"   #'projectile-rails-find-initializer
        :desc "log"                   "o"   #'projectile-rails-find-log
        :desc "environemnt"           "e"   #'projectile-rails-find-environment
        :desc "webpack"               "W"   #'projectile-rails-find-webpack
        :desc "locale"                "a"   #'projectile-rails-find-locale
        :desc "mailer"                "@"   #'projectile-rails-find-mailer
        :desc "validator"             "!"   #'projectile-rails-find-validator
        :desc "layout"                "y"   #'projectile-rails-find-layout
        :desc "rake task"             "k"   #'projectile-rails-find-rake-task
        :desc "job"                   "b"   #'projectile-rails-find-job
        :desc "serializer"            "z"   #'projectile-rails-find-serializer
        :desc "serializer (current)"  "Z"   #'projectile-rails-find-current-serializer
        :desc "extract region"        "x"   #'projectile-rails-extract-region
        :desc "goto file at point"    "RET" #'projectile-rails-goto-file-at-point)
       (:prefix ("rr" . "run")
        :desc "console"   "c" #'projectile-rails-console
        :desc "server"    "s" #'projectile-rails-server
        :desc "rake"      "r" #'projectile-rails-rake
        :desc "generate"  "g" #'projectile-rails-generate
        :desc "destroy"   "d" #'projectile-rails-destroy
        :desc "dbconsole" "C" #'projectile-rails-dbconsole)
       (:prefix ("rg" . "goto")
        :desc "file-at-point" "f" #'projectile-rails-goto-file-at-point
        :desc "gemfile"       "g" #'projectile-rails-goto-gemfile
        :desc "routes"        "r" #'projectile-rails-goto-routes
        :desc "schema"        "d" #'projectile-rails-goto-schema
        :desc "seeds"         "s" #'projectile-rails-goto-seeds
        :desc "spec helper"   "h" #'projectile-rails-goto-spec-helper
        :desc "package"       "p" #'projectile-rails-goto-package))
  nil)

(add-hook! ruby-mode #'+config:keybindings:rails)
#+end_src

** evil-rails

Ex commands for =projectile-rails=. Mainly here for =:AS= and =:AV=.

#+begin_src elisp
(after! projectile-rails
  (require 'evil-rails))
#+end_src

** apheleia

Disable autoformatting with apheleia.

#+begin_src elisp
(apheleia-global-mode -1)
(add-to-list '+format-on-save-disabled-modes 'ruby-mode)
(add-to-list '+format-on-save-disabled-modes 'web-mode)
(setq-hook! 'ruby-mode-hook +format-with 'rubocop)
(setq-hook! 'web-mode-hook apheleia-inhibit t)
#+end_src

** ruby-factory

#+begin_src elisp
(require 'yasnippet)
(require 'ruby-factory)
(add-hook! ruby-mode #'ruby-factory-mode)
#+end_src

** rspec-mode

https://github.com/pezra/rspec-mode

rspec-mode options:

#+begin_src elisp
(setq rspec-autosave-buffer t
      rspec-command-options "--backtrace --format progress --no-profile"
      rspec-spec-command "rspec"
      rspec-use-bundler-when-possible t
      rspec-use-opts-file-when-available t
      rspec-use-spring-when-possible nil)
#+end_src

Ensure test compilation buffers can run the interactive debugger.

#+begin_src elisp
(add-hook! compilation-filter #'inf-ruby-auto-enter #'evil-normal-state)
#+end_src

Unbind conflicting globally set keybindings.

#+begin_src elisp
(global-unset-key (kbd "s-RET"))
(global-unset-key (kbd "s-<return>"))
(global-unset-key (kbd "s-S-RET"))
(global-unset-key (kbd "s-S-<return>"))
#+end_src

Unbind =rspec-mode= bindings and re-bind.

#+begin_src elisp
(defun +config:keybindings:rspec ()
  (map! :map (rspec-mode-map rspec-verifiable-mode-map)
        :localleader
        :prefix "t"
        "M" nil
        "T" nil
        "a" nil
        "c" nil
        "e" nil
        "f" nil
        "f" nil
        "l" nil
        "m" nil
        "r" nil
        "s" nil
        "t" nil
        "t" nil
        "v" nil)

  (map! :map ruby-mode-map
        :ni "s-<return>"   #'rspec-verify-single
        :ni "s-RET"        #'rspec-verify-single
        :ni "s-S-<return>" #'rspec-verify
        :ni "s-S-RET"      #'rspec-verify)

  (map! :map ruby-mode-map
        :localleader
        :prefix ("t" . "test")
        :desc "all"           :n "a" #'rspec-verify-all
        :desc "buffer"        :n "b" #'rspec-verify
        :desc "buffer (test)" :n "B" #'ruby-test-run
        :desc "method"        :n "m" #'rspec-verify-method
        :desc "matching"      :n "M" #'rspec-verify-matching
        :desc "last"          :n "l" #'rspec-rerun
        :desc "last failed"   :n "L" #'rspec-run-last-failed
        :desc "single"        :n "t" #'rspec-verify-single
        :desc "single (test)" :n "T" #'ruby-test-run-at-point
        :desc "yank command"  :n "y" #'rspec-yank-last-command))

(add-hook! ruby-mode #'+config:keybindings:rspec)
#+end_src

** ruby-test

https://github.com/ruby-test-mode/ruby-test-mode

#+begin_src elisp
(setq ruby-test-rspec-options '("--backtrace" "--format progress" "--no-profile")
      ruby-test-plain-test-options '("--backtrace" "--format progress" "--no-profile")
      ruby-test-rails-test-options '("--backtrace" "--format progress" "--no-profile"))
#+end_src

** projectile-rails

Enable projectile-rails to find either a controller spec or request spec file as the alternate for a controller implementation file.

#+begin_src elisp
(defun rails--parse-project-file ()
  "Parse the current buffer's path and return a list of filename components."
  (let ((path (buffer-path-dwim)))
    (if (string-match (rx (group (or "app" "spec")) "/"
                          (group (1+ word)) "/"
                          (group (1+ anything))
                          (or "_spec.rb" ".rb"))
                      path)
        (let ((dir (match-string 1 path))
              (subdir (match-string 2 path))
              (file (replace-regexp-in-string "_spec$" "" (match-string 3 path))))
          (list `(dir . ,dir) `(subdir . ,subdir) `(file . ,file))))))
#+end_src

#+begin_src elisp
(defun rails--test-file (test-file)
  "Choose the correct test-file given TEST-FILE for the current Rails project.
Look for a request spec if there's no controller spec."
  (if (or (string-match-p "controllers" test-file) (string-match-p "requests" test-file))
      (if (file-exists-p (concat (projectile-project-root) test-file))
          test-file
        (replace-regexp-in-string "controllers?" "requests" test-file))
    test-file))
#+end_src

#+begin_src elisp
(defun rails--find-related-file (path)
  "Toggle between controller implementation at PATH and its request spec."
  (let* ((comps (rails--parse-project-file))
         (dir (alist-get 'dir comps))
         (subdir (alist-get 'subdir comps))
         (file (alist-get 'file comps)))
    (if (equal dir "spec")
        (list :impl (if (string-match-p "requests" subdir)
                        (format "app/controllers/%s.rb"
                                (replace-regexp-in-string "_requests$" "_controller" file))
                      (format "app/%s/%s.rb" subdir file)))
        (list :test (rails--test-file (format "spec/%s/%s_spec.rb" subdir file))))))
#+end_src

#+begin_src elisp
(after! projectile
  (projectile-register-project-type 'ruby-rspec
                                    '("Gemfile")
                                    :compile ""
                                    :src-dir "lib/"
                                    :test "bundle exec rspec --no-profile --format progress"
                                    :test-dir "spec/"
                                    :test-suffix "_spec"
                                    :related-files-fn #'rails--find-related-file)

  (projectile-register-project-type 'rails-rspec
                                    '("Gemfile" "app" "lib" "db" "config" "spec")
                                    :compile "bin/rails server"
                                    :src-dir "app/"
                                    :test "bin/rspec --no-profile --format progress"
                                    :test-dir "spec/"
                                    :test-suffix "_spec"
                                    :related-files-fn #'rails--find-related-file))
#+end_src

** seeing-is-believing

#+begin_src elisp
(require 'seeing-is-believing)

(setq seeing-is-believing-max-length 150
      seeing-is-believing-max-results 10
      seeing-is-believing-timeout 10.5
      seeing-is-believing-alignment 'file)

(add-hook! ruby-mode #'seeing-is-believing)

(defun xmpfilter-eval-current-line ()
  "Mark the current line for evaluation and evaluate."
  (interactive)
  (seeing-is-believing-mark-current-line-for-xmpfilter)
  (seeing-is-believing-run-as-xmpfilter))

(map! :map ruby-mode-map
      :desc "evaluate line"  "C-c C-c" #'xmpfilter-eval-current-line
      :desc "evaluate clear" "C-c C-v" #'seeing-is-believing-clear
      :desc "evaluate file"  "C-c C-f" #'seeing-is-believing-run)
#+end_src

** toggle-breakpoint

#+begin_src elisp
(defun ruby/toggle-breakpoint (&optional in-pipeline)
  "Add a break point, highlight it. Pass IN-PIPELINE to add using tap."
  (interactive "P")
  (when (eq major-mode 'ruby-mode)
    (let ((trace (cond (in-pipeline ".tap { |result| require \"pry\"; binding.pry }")
                       (t "require \"pry\"; binding.pry")))
          (line (thing-at-point 'line)))
      (if (and line (string-match trace line))
          (kill-whole-line)
        (progn
          (back-to-indentation)
          (indent-according-to-mode)
          (insert trace)
          (insert "\n")
          (indent-according-to-mode))))))

(defun python/toggle-breakpoint ()
  "Add a break point and highlight it."
  (interactive)
  (when (eq major-mode 'python-mode)
    (let ((trace "breakpoint()")
          (line (thing-at-point 'line)))
      (if (and line (string-match trace line))
          (kill-whole-line)
        (progn
          (back-to-indentation)
          (indent-according-to-mode)
          (insert trace)
          (indent-according-to-mode))))))

(map! :mode 'ruby-mode
      :localleader
      :prefix ("d" . "debug")
      :desc "binding.pry" :n "b" #'ruby/toggle-breakpoint
      :desc "binding.pry (pipeline)" :n "B" #'(lambda () (interactive) (ruby/toggle-breakpoint t)))

(map! :mode 'python-mode
      :localleader
      :prefix ("d" . "debug")
      :desc "insert breakpoint" :n "b" #'python/toggle-breakpoint)
#+end_src

** ruby-refactor

#+begin_src elisp
(setq ruby-refactor-add-parens t)
#+end_src

** flycheck

#+begin_src elisp
(defun +config:flycheck-set-checker-ruby ()
  (flycheck-select-checker 'ruby-rubocop))
(add-hook! ruby-mode #'+config:flycheck-set-checker-ruby)
#+end_src

* rust

Use tree-sitter.
#+begin_src elisp
(add-to-list 'auto-mode-alist '("\\.rs\\'" . rust-ts-mode))
#+end_src

Use =rustc= for syntax checking.
#+begin_src elisp
(defun +config:flycheck-set-checker-rust ()
  (flycheck-select-checker 'rust))
(add-hook! rust-ts-mode #'+config:flycheck-set-checker-rust)
#+end_src

* smartparens

Enable strict smartparens mode wherever smartparens is enabled.

#+begin_src elisp
(after! smartparens
  (setq smartparens-global-mode nil
        smartparens-global-strict-mode nil))
#+end_src

* treesitter

#+begin_src elisp
(after! treesit
  (setq treesit-language-source-alist
        '((rust "https://github.com/tree-sitter/tree-sitter-rust" nil "src")
          (c      "https://github.com/tree-sitter/tree-sitter-c" nil "src")
          (cpp    "https://github.com/tree-sitter/tree-sitter-cpp" nil "src")
          (r    "https://github.com/r-lib/tree-sitter-r" nil "src"))))
#+end_src

* typopunct

https://www.emacswiki.org/emacs/TypographicalPunctuationMarks

#+begin_src elisp
(require 'typopunct)

(defun +config:typopunct:enable ()
  "Set up typopunct mode."
  (typopunct-change-language 'english t)
  (typopunct-mode 1))

;; (add-hook! '(org-mode-hook markdown-mode-hook) #'+config:typopunct:enable)
#+end_src

* webkit

Reminders:

- There's a long-standing bug whereby killing a browser buffer disables =ESC= until a restart. Bury browser buffers instead.
- Use in-emacs browser sessions only for security-insensitive tasks (reading documentation, etc.)
- NB: Watching [[https://github.com/akirakyle/emacs-webkit][emacs-webkit]]

** xwwp

#+begin_src elisp
(require 'xwwp)
#+end_src

** browser-open keybindings

#+begin_src elisp
(map! :n "g F" #'browser-open-dwim)
#+end_src

** browser-open commands

#+begin_src elisp
(defun browser-open-dwim (use-new-session)
  "Open webkit and navigate to a destination in the precedence order described below.
If given the prefix argument USE-NEW-SESSION, use a new session instead of re-using an existing webkit session.

Precedence order:

1. With a region selected that resembles a URL, navigate to it.
2. With a region selected that doesn't resemble a URL, perform a web search with the selected string.
3. With the point on a contiguous string that resembles a URL, attempt to navigate to it.
4. Finally, if none of the preceding apply, prompt the user to input a URL or search term."
  (interactive "P")
  (let* ((region-text (when (use-region-p)
                        (buffer-substring (region-beginning) (region-end))))
         (url-at-point (unless region-text (ensure-url (get-url-surrounding-point))))
         (history '("localhost:" "google.com"))
         (user-input (unless (or region-text url-at-point)
                       (string-trim (read-from-minibuffer "goto: " "localhost:" nil nil '(history . 1)))))
         (user-text (unless (string= "" user-input)
                      user-input)))
    (when-let ((target-str (or region-text url-at-point user-text)))
        (xwwp target-str use-new-session))))
#+end_src

** xwidget-widget keybindings

#+begin_src elisp
(defun +config:keybindings:xwidget-webkit ()
  "Configure xwidget keybindings."
  (evil-define-key*
    'normal xwidget-webkit-mode-map
    "g"  nil
    "f"  #'xwwp-follow-link
    "gf" #'browser-open-dwim
    "gg" #'xwidget-webkit-scroll-top
    "G"  #'xwidget-webkit-scroll-bottom
    "h"  #'xwidget-webkit-back
    "l"  #'xwidget-webkit-forward
    "r"  #'xwidget-webkit-reload
    "y"  #'xwidget-webkit-copy-selection-as-kill
    "Y"  #'xwidget-webkit-current-url-message-kill))

(evil-set-initial-state 'xwidget-webkit-mode 'normal)
(add-hook! xwidget-webkit-mode #'+config:keybindings:xwidget-webkit)
#+end_src

** smooth scrolling

#+begin_src elisp
(after! xwidget
  (defun +xwidget-webkit-smooth-scroll-down ()
    "Smooth scroll down in webkit."
    (interactive)
    (xwidget-webkit-execute-script (xwidget-webkit-current-session)
                                   "window.scrollBy({top: 30, behavior: 'smooth'});"))

  (defun +xwidget-webkit-smooth-scroll-up ()
    "Smooth scroll up in webkit."
    (interactive)
    (xwidget-webkit-execute-script (xwidget-webkit-current-session)
                                   "window.scrollBy({top: -30, behavior: 'smooth'});"))

  (map! :map xwidget-webkit-mode-map
        :n "j" #'+xwidget-webkit-smooth-scroll-down
        :n "k" #'+xwidget-webkit-smooth-scroll-up))
#+end_src

* word chars

#+begin_src elisp
(defun +config:add-dot-to-word-chars ()
  "Adds underscore to the word chars syntax entry list."
  (modify-syntax-entry ?. "w"))

(defun +config:add-underscore-to-word-chars ()
  "Adds underscore to the word chars syntax entry list."
  (modify-syntax-entry ?_ "w"))

(defun +config:add-dash-to-word-chars ()
  "Adds underscore to the word chars syntax entry list."
  (modify-syntax-entry ?- "w"))

(defun +config:add-to-word-char-list ()
  "Customize the word char list in prog and other modes."
  (add-hook! LaTeX-mode      #'+config:add-dot-to-word-chars)
  (add-hook! latex-mode      #'+config:add-dot-to-word-chars)
  (add-hook! coffee-mode     #'+config:add-dash-to-word-chars)
  (add-hook! coffee-mode     #'+config:add-underscore-to-word-chars)
  (add-hook! emacs-lisp-mode #'+config:add-dash-to-word-chars)
  (add-hook! markdown-mode   #'+config:add-underscore-to-word-chars)
  (add-hook! org-mode        #'+config:add-underscore-to-word-chars)
  (add-hook! prog-mode       #'+config:add-dash-to-word-chars)
  (add-hook! prog-mode       #'+config:add-underscore-to-word-chars)
  (add-hook! python-mode     #'+config:add-underscore-to-word-chars)
  (add-hook! restclient-mode #'+config:add-underscore-to-word-chars)
  (add-hook! text-mode       #'+config:add-underscore-to-word-chars)
  nil)

(+config:add-to-word-char-list)
#+end_src

* workspaces

** open config workspace

#+begin_src elisp
(defun +open-dotfiles ()
  "Create a new workspace, switch to it, then open the DOTFILES_DIR in dired."
  (interactive)
  (progn
    (+workspace/new "dotfiles")
    (+workspace/switch-to-final)
    (find-file (getenv "DOTFILES_DIR"))))
#+end_src

** startup workspace

Open on main org todo doc.

#+begin_src elisp :tangle no
(defun +open-org-todos ()
  "Open the main Org mode file in the main workspace."
  (find-file (format "%s/%s" (getenv "ORG_HOME") +org-capture-todo-file)))
(add-hook 'emacs-startup-hook #'+open-org-todos)
#+end_src

Open a new draft buffer.

#+begin_src elisp
(defun +new-draft-buffer ()
  (interactive)
  (switch-to-buffer (get-buffer-create "*draft*")))
#+end_src

Open on an empty buffer in the main workspace.

#+begin_src elisp
(after! persp-mode
  (setq persp-emacsclient-init-frame-behaviour-override "main") ;; Ensure clients attach to the "main" workspace
  (setq persp-set-last-persp-for-new-frames t)) ;; Keep last workspace for new frames
#+end_src

** configuration

#+begin_src elisp
(setq +workspaces-on-switch-project-behavior 'non-empty)
#+end_src

** keybindings

#+begin_src elisp
(map! "s-t" #'+workspace/clone
      "s-T" #'+workspace/new
      "s-;" #'+workspace/other
      "s-{" #'+workspace/switch-left
      "s-}" #'+workspace/switch-right)
#+end_src

** new tab behavior

Clone the current workspace when opening a new one. Name it intelligently.

#+begin_src elisp
(defun +workspace/clone ()
  "Clone the current workspace, naming it with the next available sequential index.
If started from an indexed workspace (e.g., 'name:5'), fills in gaps from 1 upward.
Creates 'name:1' if it doesn't exist yet and places it to the left.
Only creates the next higher index if all lower indices exist."
  (interactive)
  (let* ((curr-name (+workspace-current-name))
         ;; Extract base name and current index (if any)
         (curr-has-index (string-match "\\(.*\\):\\([0-9]+\\)$" curr-name))
         (base-name (if curr-has-index
                        (match-string 1 curr-name)
                      curr-name))
         (curr-index (when curr-has-index
                       (string-to-number (match-string 2 curr-name))))
         (names (+workspace-list-names))
         ;; Find all workspaces with the same base name and extract their indices
         (indices (delq nil
                        (mapcar (lambda (name)
                                  (when (string-match (concat (regexp-quote base-name) ":\\([0-9]+\\)$") name)
                                    (string-to-number (match-string 1 name))))
                                names)))
         ;; Sort indices to find gaps
         (sorted-indices (sort indices #'<))

         ;; Find the next sequential gap starting from 1, regardless of current index
         (next-index (let ((expected 1))
                       (while (member expected sorted-indices)
                         (setq expected (1+ expected)))
                       expected))

         ;; If all sequential indices from 1 up to current max exist, then use the next number
         (highest-index (if sorted-indices (apply #'max sorted-indices) 0))
         (next-index (if (and (= next-index (1+ highest-index))
                              (= (length sorted-indices) highest-index))
                         (1+ highest-index)
                       next-index))

         ;; New workspace name with the next available index
         (next-name (format "%s:%d" base-name next-index))

         ;; Find the indices immediately before and after our new index
         (index-before (cl-loop for idx in sorted-indices
                                when (< idx next-index)
                                collect idx into before-indices
                                finally return (if before-indices
                                                   (apply #'max before-indices)
                                                 nil)))
         (index-after (cl-loop for idx in sorted-indices
                               when (> idx next-index)
                               return idx
                               finally return nil))

         ;; Get workspace names for positioning
         (workspace-before (cond
                            (index-before (format "%s:%d" base-name index-before))
                            ((= next-index 1) base-name) ; If creating index 1, position after base
                            (t nil)))
         (workspace-after (and index-after (format "%s:%d" base-name index-after)))

         ;; Find positions in the workspace list
         (before-pos (and workspace-before (cl-position workspace-before names :test #'equal)))
         (after-pos (and workspace-after (cl-position workspace-after names :test #'equal))))

    ;; Create the new workspace
    (+workspace/new next-name t)

    ;; Determine where to insert the new workspace
    (let* ((updated-names (+workspace-list-names))
           (new-pos (cl-position next-name updated-names :test #'equal)))
      (cond
       ;; If there's a workspace after where this should go, position before it
       (after-pos
        (let ((target-pos after-pos)
              (current-pos new-pos))
          (when (> current-pos target-pos)
            ;; We need to move the workspace left
            (+workspace/swap-left (- current-pos target-pos)))))

       ;; If there's a workspace before where this should go, position after it
       (before-pos
        (let ((target-pos (1+ before-pos))
              (current-pos new-pos))
          (cond
           ((> current-pos target-pos)
            ;; Need to move left
            (+workspace/swap-left (- current-pos target-pos)))
           ((< current-pos target-pos)
            ;; Need to move right
            (+workspace/swap-right (- target-pos current-pos))))))

       ;; If this is the first indexed workspace, place it after the base workspace
       (t
        (let ((base-pos (cl-position base-name updated-names :test #'equal)))
          (when base-pos
            (let ((target-pos (1+ base-pos))
                  (current-pos new-pos))
              (when (> current-pos target-pos)
                (+workspace/swap-left (- current-pos target-pos))))))))

      ;; Keep the focus on the new workspace
      (+workspace-switch next-name))
    (+workspace/display)))
#+end_src

Helper function to increment a string with a numeric suffix.

#+begin_src elisp
(defun +workspace--increment-name (text)
  "Transform workspace names by adding or incrementing a numeric suffix.
Examples: 'workspace' -> 'workspace:1', 'workspace:1' -> 'workspace:2'"
  (interactive "sEnter workspace text: ")
  (let ((result
         (if (string-match "\\(.*\\):\\([0-9]+\\)$" text)
             ;; If text ends with :number, increment the number
             (let* ((base (match-string 1 text))
                    (num (string-to-number (match-string 2 text))))
               (format "%s:%d" base (1+ num)))
           ;; If no number exists, add :1
           (format "%s:1" text))))
    (when (called-interactively-p 'interactive)
      (message "%s" result))
    result))
#+end_src

** project switching

When switching to a project, abbreviate the workspace name.

#+begin_src elisp
(defun +name-workspace-open-project-dired (project)
  "Switch to a project and open dired, while setting a custom workspace name."
  (interactive)
  (let* ((proj-root (doom-project-root project))
         (raw-name (file-name-nondirectory (directory-file-name proj-root)))
         (proj-name (string-trim raw-name "^[[:punct:]]+" "[[:punct:]]+$"))
         (new-name (cond ((string-match-p "-" proj-name)
                          (car (split-string proj-name "-")))
                         ((string-match-p " " proj-name)
                          (downcase (mapconcat (lambda (s) (substring s 0 1))
                                               (split-string proj-name " ")
                                               "")))
                         (t proj-name))))
    (dired proj-root)
    (+workspace/rename new-name)))

(setq +workspaces-switch-project-function #'+name-workspace-open-project-dired)
#+end_src

#+end_src

** =+workspace/kill= behavior

When killing a workspace, consistently move to the one on the immediate left.

#+begin_src elisp
(after! persp-mode
  (defadvice! +workspace/kill-and-shift-left (orig-fn &rest args)
    "Move to the workspace on the left after deleting the current one."
    :around #'+workspace/kill
    (let ((name (+workspace-current-name)))
      (+workspace/switch-left 1)
      (funcall orig-fn name))))
#+end_src

* yankee

Set keybindings for visual mode.

#+begin_src elisp
(require 'yankee)
#+end_src

Set parameters for =copy-as-format=.

#+begin_src elisp
(setq copy-as-format-asciidoc-include-file-name t
      copy-as-format-default "github")
#+end_src

** perfidious-yanqui

Add some yankee motions for evil mode.

#+begin_src elisp
(defun perfidious-yank-inner (textobj)
  "docstring"
  (interactive)
  (let ((evil-textobj (intern (format "evil-inner-%s" textobj)))
        (start-pos (point)))
    (save-excursion
      (let* ((bounds (call-interactively evil-textobj))
             (beg (cl-first bounds))
             (end (cl-second bounds)))
        (progn
          (evil-visual-char beg end)
          (yankee-yank beg end))))
    (goto-char start-pos)))

(defun perfidious-yank-inner-paragraph ()
  "Yank the current paragraph with annotations using `yankee-yank'."
  (interactive)
  (perfidious-yank-inner 'paragraph))

(defun perfidious-yank-inner-buffer ()
  "Yank the current buffer with annotations using `yankee-yank'."
  (interactive)
  (perfidious-yank-inner 'buffer))

(after! yankee
  (map! (:prefix "g"
         :v "y" #'yankee-yank
         :n "y" nil
         (:prefix ("y" . "yanqui")
          :desc "yanq paragraph"        :n "p" #'perfidious-yank-inner-paragraph
          :desc "yanq buffer"           :n "b" #'perfidious-yank-inner-buffer))))
#+end_src

* yasnippet

#+begin_src elisp
(defun yas/camelcase-file-name ()
  "Camel-case the current buffer's file name."
  (interactive)
  (let ((filename
         (file-name-nondirectory (file-name-sans-extension
                                  (or (buffer-file-name)
                                      (buffer-name (current-buffer)))))))
    (mapconcat #'capitalize (split-string filename "[_\-]") "")))

(defun yas/strip (str)
  "Extract a parameter name from STR."
  (replace-regexp-in-string ":.*$" ""
   (replace-regexp-in-string "^\s+" ""
    (replace-regexp-in-string "," ""
     str))))

(defun yas/to-field-assignment (str)
  "Make 'STR' to 'self.`STR` = `STR`'."
  (format "self.%s = %s" (yas/strip str) (yas/strip str)))

(defun yas/prepend-colon (str)
  "Make `STR' to :`STR'."
  (format ":%s" (yas/strip str)))

(defun yas/indent-level ()
  "Determine the number of spaces the current line is indented."
  (interactive)
  (string-match "[^[:space:]]" (thing-at-point 'line t)))

(defun yas/indent-string ()
  "Return a string of spaces matching the current indentation level."
  (interactive)
  (make-string (yas/indent-level) ?\s))

(defun yas/indented-newline ()
  "Newline followed by correct indentation."
  (interactive)
  (format "\n%s" (yas/indent-string)))

(defun yas/args-list ()
  "Extract an args list from the current line."
  (interactive)
  (string-match "\(.+\)" (thing-at-point 'line t)))

(defun yas/to-ruby-accessors (str)
  "Splits STR into an `attr_accesor' statement."
  (interactive)
  (mapconcat 'yas/prepend-colon (split-string str ",") ", "))

(defun yas/to-ruby-setters (str)
  "Splits STR into a sequence of field assignments."
  (interactive)
  (mapconcat 'yas/to-field-assignment
             (split-string str ",")
             (yas/indented-newline)))
#+end_src

* hacks

TEMP: Restore missing org-eldoc function invoked when evaluating region

#+begin_src elisp
(defun org-eldoc-get-src-lang ()
  "Return value of lang for the current block if in block body and nil otherwise."
  (let ((element (save-match-data (org-element-at-point))))
    (and (eq (org-element-type element) 'src-block)
    (>= (line-beginning-position)
        (org-element-property :post-affiliated element))
    (<=
     (line-end-position)
     (org-with-wide-buffer
      (goto-char (org-element-property :end element))
      (skip-chars-backward " \t\n")
      (line-end-position)))
    (org-element-property :language element))))
#+end_src
